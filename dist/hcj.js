/* The code in this file is copied from a variety of sources on the internet. */


/* globals define, exports, module */

(function(root, definition) {
  window.FontLoader = definition();
}(window, function() {

  var isIE = /MSIE/i.test(navigator.userAgent),
      ieVer = null;

  // Get Internet Explorer version
  if (isIE) {
    var re, result;
    re = new RegExp("MSIE ([0-9]{1,}[.0-9]{0,})");
    result = re.exec(navigator.userAgent);
    if (result !== null) {
      ieVer = parseFloat(result[1]);
    }
  }

  /**
   * @typedef {Object} FontDescriptor
   * @property {String} family
   * @property {String} weight
   * @property {String} style
   * @property {String} stretch
   */
  function FontDescriptor(fontDescriptor) {
    this._validateFontDescriptor(fontDescriptor);
    this.family = fontDescriptor.family;
    this.weight = fontDescriptor.weight;
    this.style = fontDescriptor.style;
    this.stretch = fontDescriptor.stretch;
  }

  FontDescriptor.prototype = {
    constructor: FontDescriptor,
    /**
     * Returns font variation identifier of the FontDescriptor.
     *
     * FontDescriptors with different family-names may have same variation identifiers.
     * This identifier is useful for mapping and storing font dimensions of fallback fonts with font variation
     * properties similar to these of the loaded fonts.
     *
     * @returns {string}
     */
    variationKey: function() {
      return this.weight + this.style + this.stretch;
    },
    /**
     * Returns identifier of the FontDescriptor.
     *
     * @returns {string}
     */
    fontKey: function() {
      return this.family + this.variationKey();
    },
    toJSON: function() {
      return {
        family: this.family,
        weight: this.weight,
        style: this.style,
        stretch: this.stretch
      };
    },
    _validateFontDescriptor: function(fontDescriptor) {
      var style, stretch;

      if (!fontDescriptor.family || !fontDescriptor.weight || !fontDescriptor.style) {
        throw new Error("Illegal font descriptor, family, weight and style properties are required.")
      }

      if (!('possibleFontStyles' in FontLoader)) {
        FontLoader.possibleFontStyles = [];
        for (style in FontLoader.fontStyleAliasesMap) {
          if (FontLoader.fontStyleAliasesMap.hasOwnProperty(style)) {
            FontLoader.possibleFontStyles.push(FontLoader.fontStyleAliasesMap[style]);
          }
        }
      }
      if (FontLoader.possibleFontStyles.indexOf(fontDescriptor.style) === -1) {
        throw new Error("Illegal font descriptor, style property must be one of the following: " + FontLoader.possibleFontStyles.join(", "));
      }

      // For backward compatibility do not require "stretch" property
      if ('stretch' in fontDescriptor) {
        if (!('possibleFontStretches' in FontLoader)) {
          FontLoader.possibleFontStretches = [];
          for (stretch in FontLoader.fontStretchAliasesMap) {
            if (FontLoader.fontStretchAliasesMap.hasOwnProperty(stretch)) {
              FontLoader.possibleFontStretches.push(FontLoader.fontStretchAliasesMap[stretch]);
            }
          }
        }
        if (FontLoader.possibleFontStretches.indexOf(fontDescriptor.stretch) === -1) {
          throw new Error("Illegal font descriptor, stretch property must be one of the following: " + FontLoader.possibleFontStretches.join(", "));
        }
      } else {
        fontDescriptor.stretch = 'normal';
      }
    }
  };

  /**
   * FontLoader detects when web fonts specified in the "fontFamiliesArray" array were loaded and rendered. Then it
   * notifies the specified delegate object via "fontLoaded" and "complete" methods when specific or all fonts were
   * loaded respectively. The use of this functions implies that the insertion of specified web fonts into the
   * document is done elsewhere.
   *
   * The fonts parameter may be an array of strings specifying the font-families with optionally specified font
   * variations using FVD notation or font descriptor objects of the following type:
   * {
   *     family: "fontFamily",
   *     weight: 400,
   *     style: 'normal',
   *     stretch: 'normal'
   * }
   * Where styles may ne one of the following: normal, bold, italic or oblique. If only string is specified, the
   * default values used for weight, style and stretch are 400, 'normal' and 'normal' respectively.
   *
   * If all the specified fonts were loaded before the timeout was reached, the "complete" delegate method will be
   * invoked with "null" error parameter. Otherwise, if timeout was reached before all specified fonts were loaded,
   * the "complete" method will be invoked with an error object with two fields: the "message" string and the
   * "notLoadedFonts" array of FontDescriptor objects of all the fonts that weren't loaded.
   *
   * @param {Array.<String|FontDescriptor>} fonts   Array of font-family strings or font descriptor objects.
   * @param {Object}        delegate                Delegate object whose callback methods will be invoked in its own context.
   * @param {Function}      [delegate.complete]     Called when all fonts were loaded or the timeout was reached.
   * @param {Function}      [delegate.fontLoaded]   Called for each loaded font with its font-family string as its single parameter.
   * @param {Number}        [timeout=3000]          Timeout in milliseconds. Pass "null" to disable timeout.
   * @param {HTMLDocument}  [contextDocument]       The DOM tree context to use, if none provided then it will be the document.
   * @constructor
   */
  function FontLoader(fonts, delegate, timeout, contextDocument) {
    // Public
    this.delegate = delegate;
    this.timeout = (typeof timeout !== "undefined") ? timeout : 3000;

    // Private
    this._fontsArray = this._parseFonts(fonts);
    this._started = false;
    this._testDiv = null;
    this._testContainer = null;
    this._adobeBlankSizeWatcher = null;
    this._sizeWatchers = [];
    this._timeoutId = null;
    this._intervalId = null;
    this._intervalDelay = 50;
    this._numberOfLoadedFonts = 0;
    this._numberOfFonts = this._fontsArray.length;
    this._fontsMap = {};
    this._finished = false;
    this._document = contextDocument || document;
  }

  FontLoader.useAdobeBlank = !isIE || ieVer >= 11.0;
  FontLoader.useResizeEvent = isIE && ieVer < 11.0 && typeof document.attachEvent !== "undefined";
  FontLoader.useIntervalChecking = window.opera || (isIE && ieVer < 11.0 && !FontLoader.useResizeEvent);
  FontLoader.referenceText = " !\"\\#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~";
  FontLoader.referenceFontFamilies = FontLoader.useAdobeBlank ? ["AdobeBlank"] : ["serif", "cursive"];
  FontLoader.adobeBlankFontFaceStyleId = "fontLoaderAdobeBlankFontFace";
  FontLoader.adobeBlankReferenceSize = null;
  FontLoader.referenceFontFamilyVariationSizes = {};
  FontLoader.adobeBlankFontFaceRule = "@font-face{ font-family:AdobeBlank; src:url('data:font/opentype;base64,T1RUTwAKAIAAAwAgQ0ZGIM6ZbkwAAEPEAAAZM0RTSUcAAAABAABtAAAAAAhPUy8yAR6vMwAAARAAAABgY21hcDqI98oAACjEAAAa4GhlYWT+BQILAAAArAAAADZoaGVhCCID7wAAAOQAAAAkaG10eAPoAHwAAFz4AAAQBm1heHAIAVAAAAABCAAAAAZuYW1lD/tWxwAAAXAAACdScG9zdP+4ADIAAEOkAAAAIAABAAAAAQj1Snw1O18PPPUAAwPoAAAAAM2C2p8AAAAAzYLanwB8/4gDbANwAAAAAwACAAAAAAAAAAEAAANw/4gAyAPoAHwAfANsAAEAAAAAAAAAAAAAAAAAAAACAABQAAgBAAAABAAAAZAABQAAAooCWAAAAEsCigJYAAABXgAyANwAAAAAAAAAAAAAAAD3/67/+9///w/gAD8AAAAAQURCRQHAAAD//wNw/4gAyANwAHhgLwH/AAAAAAAAAAAAAAAgAAAAAAARANIAAQAAAAAAAQALAAAAAQAAAAAAAgAHAAsAAQAAAAAAAwAbABIAAQAAAAAABAALAAAAAQAAAAAABQA5AC0AAQAAAAAABgAKAGYAAwABBAkAAABuAHAAAwABBAkAAQAWAN4AAwABBAkAAgAOAPQAAwABBAkAAwA2AQIAAwABBAkABAAWAN4AAwABBAkABQByATgAAwABBAkABgAUAaoAAwABBAkACAA0Ab4AAwABBAkACwA0AfIAAwABBAkADSQSAiYAAwABBAkADgBIJjhBZG9iZSBCbGFua1JlZ3VsYXIxLjAzNTtBREJFO0Fkb2JlQmxhbms7QURPQkVWZXJzaW9uIDEuMDM1O1BTIDEuMDAzO2hvdGNvbnYgMS4wLjcwO21ha2VvdGYubGliMi41LjU5MDBBZG9iZUJsYW5rAKkAIAAyADAAMQAzACAAQQBkAG8AYgBlACAAUwB5AHMAdABlAG0AcwAgAEkAbgBjAG8AcgBwAG8AcgBhAHQAZQBkAC4AIABBAGwAbAAgAFIAaQBnAGgAdABzACAAUgBlAHMAZQByAHYAZQBkAC4AQQBkAG8AYgBlACAAQgBsAGEAbgBrAFIAZQBnAHUAbABhAHIAMQAuADAAMwA1ADsAQQBEAEIARQA7AEEAZABvAGIAZQBCAGwAYQBuAGsAOwBBAEQATwBCAEUAVgBlAHIAcwBpAG8AbgAgADEALgAwADMANQA7AFAAUwAgADEALgAwADAAMwA7AGgAbwB0AGMAbwBuAHYAIAAxAC4AMAAuADcAMAA7AG0AYQBrAGUAbwB0AGYALgBsAGkAYgAyAC4ANQAuADUAOQAwADAAQQBkAG8AYgBlAEIAbABhAG4AawBBAGQAbwBiAGUAIABTAHkAcwB0AGUAbQBzACAASQBuAGMAbwByAHAAbwByAGEAdABlAGQAaAB0AHQAcAA6AC8ALwB3AHcAdwAuAGEAZABvAGIAZQAuAGMAbwBtAC8AdAB5AHAAZQAvAEEAZABvAGIAZQAgAEIAbABhAG4AawAgAGkAcwAgAHIAZQBsAGUAYQBzAGUAZAAgAHUAbgBkAGUAcgAgAHQAaABlACAAUwBJAEwAIABPAHAAZQBuACAARgBvAG4AdAAgAEwAaQBjAGUAbgBzAGUAIAAtACAAcABsAGUAYQBzAGUAIAByAGUAYQBkACAAaQB0ACAAYwBhAHIAZQBmAHUAbABsAHkAIABhAG4AZAAgAGQAbwAgAG4AbwB0ACAAZABvAHcAbgBsAG8AYQBkACAAdABoAGUAIABmAG8AbgB0AHMAIAB1AG4AbABlAHMAcwAgAHkAbwB1ACAAYQBnAHIAZQBlACAAdABvACAAdABoAGUAIAB0AGgAZQAgAHQAZQByAG0AcwAgAG8AZgAgAHQAaABlACAAbABpAGMAZQBuAHMAZQA6AA0ACgANAAoAQwBvAHAAeQByAGkAZwBoAHQAIACpACAAMgAwADEAMwAgAEEAZABvAGIAZQAgAFMAeQBzAHQAZQBtAHMAIABJAG4AYwBvAHIAcABvAHIAYQB0AGUAZAAgACgAaAB0AHQAcAA6AC8ALwB3AHcAdwAuAGEAZABvAGIAZQAuAGMAbwBtAC8AKQAsACAAdwBpAHQAaAAgAFIAZQBzAGUAcgB2AGUAZAAgAEYAbwBuAHQAIABOAGEAbQBlACAAQQBkAG8AYgBlACAAQgBsAGEAbgBrAA0ACgANAAoAVABoAGkAcwAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUAIABpAHMAIABsAGkAYwBlAG4AcwBlAGQAIAB1AG4AZABlAHIAIAB0AGgAZQAgAFMASQBMACAATwBwAGUAbgAgAEYAbwBuAHQAIABMAGkAYwBlAG4AcwBlACwAIABWAGUAcgBzAGkAbwBuACAAMQAuADEALgANAAoADQAKAFQAaABpAHMAIABsAGkAYwBlAG4AcwBlACAAaQBzACAAYwBvAHAAaQBlAGQAIABiAGUAbABvAHcALAAgAGEAbgBkACAAaQBzACAAYQBsAHMAbwAgAGEAdgBhAGkAbABhAGIAbABlACAAdwBpAHQAaAAgAGEAIABGAEEAUQAgAGEAdAA6ACAAaAB0AHQAcAA6AC8ALwBzAGMAcgBpAHAAdABzAC4AcwBpAGwALgBvAHIAZwAvAE8ARgBMAA0ACgANAAoALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAA0ACgBTAEkATAAgAE8AUABFAE4AIABGAE8ATgBUACAATABJAEMARQBOAFMARQAgAFYAZQByAHMAaQBvAG4AIAAxAC4AMQAgAC0AIAAyADYAIABGAGUAYgByAHUAYQByAHkAIAAyADAAMAA3AA0ACgAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ALQAtAC0ADQAKAA0ACgBQAFIARQBBAE0AQgBMAEUADQAKAFQAaABlACAAZwBvAGEAbABzACAAbwBmACAAdABoAGUAIABPAHAAZQBuACAARgBvAG4AdAAgAEwAaQBjAGUAbgBzAGUAIAAoAE8ARgBMACkAIABhAHIAZQAgAHQAbwAgAHMAdABpAG0AdQBsAGEAdABlACAAdwBvAHIAbABkAHcAaQBkAGUAIABkAGUAdgBlAGwAbwBwAG0AZQBuAHQAIABvAGYAIABjAG8AbABsAGEAYgBvAHIAYQB0AGkAdgBlACAAZgBvAG4AdAAgAHAAcgBvAGoAZQBjAHQAcwAsACAAdABvACAAcwB1AHAAcABvAHIAdAAgAHQAaABlACAAZgBvAG4AdAAgAGMAcgBlAGEAdABpAG8AbgAgAGUAZgBmAG8AcgB0AHMAIABvAGYAIABhAGMAYQBkAGUAbQBpAGMAIABhAG4AZAAgAGwAaQBuAGcAdQBpAHMAdABpAGMAIABjAG8AbQBtAHUAbgBpAHQAaQBlAHMALAAgAGEAbgBkACAAdABvACAAcAByAG8AdgBpAGQAZQAgAGEAIABmAHIAZQBlACAAYQBuAGQAIABvAHAAZQBuACAAZgByAGEAbQBlAHcAbwByAGsAIABpAG4AIAB3AGgAaQBjAGgAIABmAG8AbgB0AHMAIABtAGEAeQAgAGIAZQAgAHMAaABhAHIAZQBkACAAYQBuAGQAIABpAG0AcAByAG8AdgBlAGQAIABpAG4AIABwAGEAcgB0AG4AZQByAHMAaABpAHAAIAB3AGkAdABoACAAbwB0AGgAZQByAHMALgANAAoADQAKAFQAaABlACAATwBGAEwAIABhAGwAbABvAHcAcwAgAHQAaABlACAAbABpAGMAZQBuAHMAZQBkACAAZgBvAG4AdABzACAAdABvACAAYgBlACAAdQBzAGUAZAAsACAAcwB0AHUAZABpAGUAZAAsACAAbQBvAGQAaQBmAGkAZQBkACAAYQBuAGQAIAByAGUAZABpAHMAdAByAGkAYgB1AHQAZQBkACAAZgByAGUAZQBsAHkAIABhAHMAIABsAG8AbgBnACAAYQBzACAAdABoAGUAeQAgAGEAcgBlACAAbgBvAHQAIABzAG8AbABkACAAYgB5ACAAdABoAGUAbQBzAGUAbAB2AGUAcwAuACAAVABoAGUAIABmAG8AbgB0AHMALAAgAGkAbgBjAGwAdQBkAGkAbgBnACAAYQBuAHkAIABkAGUAcgBpAHYAYQB0AGkAdgBlACAAdwBvAHIAawBzACwAIABjAGEAbgAgAGIAZQAgAGIAdQBuAGQAbABlAGQALAAgAGUAbQBiAGUAZABkAGUAZAAsACAAcgBlAGQAaQBzAHQAcgBpAGIAdQB0AGUAZAAgAGEAbgBkAC8AbwByACAAcwBvAGwAZAAgAHcAaQB0AGgAIABhAG4AeQAgAHMAbwBmAHQAdwBhAHIAZQAgAHAAcgBvAHYAaQBkAGUAZAAgAHQAaABhAHQAIABhAG4AeQAgAHIAZQBzAGUAcgB2AGUAZAAgAG4AYQBtAGUAcwAgAGEAcgBlACAAbgBvAHQAIAB1AHMAZQBkACAAYgB5ACAAZABlAHIAaQB2AGEAdABpAHYAZQAgAHcAbwByAGsAcwAuACAAVABoAGUAIABmAG8AbgB0AHMAIABhAG4AZAAgAGQAZQByAGkAdgBhAHQAaQB2AGUAcwAsACAAaABvAHcAZQB2AGUAcgAsACAAYwBhAG4AbgBvAHQAIABiAGUAIAByAGUAbABlAGEAcwBlAGQAIAB1AG4AZABlAHIAIABhAG4AeQAgAG8AdABoAGUAcgAgAHQAeQBwAGUAIABvAGYAIABsAGkAYwBlAG4AcwBlAC4AIABUAGgAZQAgAHIAZQBxAHUAaQByAGUAbQBlAG4AdAAgAGYAbwByACAAZgBvAG4AdABzACAAdABvACAAcgBlAG0AYQBpAG4AIAB1AG4AZABlAHIAIAB0AGgAaQBzACAAbABpAGMAZQBuAHMAZQAgAGQAbwBlAHMAIABuAG8AdAAgAGEAcABwAGwAeQAgAHQAbwAgAGEAbgB5ACAAZABvAGMAdQBtAGUAbgB0ACAAYwByAGUAYQB0AGUAZAAgAHUAcwBpAG4AZwAgAHQAaABlACAAZgBvAG4AdABzACAAbwByACAAdABoAGUAaQByACAAZABlAHIAaQB2AGEAdABpAHYAZQBzAC4ADQAKAA0ACgBEAEUARgBJAE4ASQBUAEkATwBOAFMADQAKACIARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAiACAAcgBlAGYAZQByAHMAIAB0AG8AIAB0AGgAZQAgAHMAZQB0ACAAbwBmACAAZgBpAGwAZQBzACAAcgBlAGwAZQBhAHMAZQBkACAAYgB5ACAAdABoAGUAIABDAG8AcAB5AHIAaQBnAGgAdAAgAEgAbwBsAGQAZQByACgAcwApACAAdQBuAGQAZQByACAAdABoAGkAcwAgAGwAaQBjAGUAbgBzAGUAIABhAG4AZAAgAGMAbABlAGEAcgBsAHkAIABtAGEAcgBrAGUAZAAgAGEAcwAgAHMAdQBjAGgALgAgAFQAaABpAHMAIABtAGEAeQAgAGkAbgBjAGwAdQBkAGUAIABzAG8AdQByAGMAZQAgAGYAaQBsAGUAcwAsACAAYgB1AGkAbABkACAAcwBjAHIAaQBwAHQAcwAgAGEAbgBkACAAZABvAGMAdQBtAGUAbgB0AGEAdABpAG8AbgAuAA0ACgANAAoAIgBSAGUAcwBlAHIAdgBlAGQAIABGAG8AbgB0ACAATgBhAG0AZQAiACAAcgBlAGYAZQByAHMAIAB0AG8AIABhAG4AeQAgAG4AYQBtAGUAcwAgAHMAcABlAGMAaQBmAGkAZQBkACAAYQBzACAAcwB1AGMAaAAgAGEAZgB0AGUAcgAgAHQAaABlACAAYwBvAHAAeQByAGkAZwBoAHQAIABzAHQAYQB0AGUAbQBlAG4AdAAoAHMAKQAuAA0ACgANAAoAIgBPAHIAaQBnAGkAbgBhAGwAIABWAGUAcgBzAGkAbwBuACIAIAByAGUAZgBlAHIAcwAgAHQAbwAgAHQAaABlACAAYwBvAGwAbABlAGMAdABpAG8AbgAgAG8AZgAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUAIABjAG8AbQBwAG8AbgBlAG4AdABzACAAYQBzACAAZABpAHMAdAByAGkAYgB1AHQAZQBkACAAYgB5ACAAdABoAGUAIABDAG8AcAB5AHIAaQBnAGgAdAAgAEgAbwBsAGQAZQByACgAcwApAC4ADQAKAA0ACgAiAE0AbwBkAGkAZgBpAGUAZAAgAFYAZQByAHMAaQBvAG4AIgAgAHIAZQBmAGUAcgBzACAAdABvACAAYQBuAHkAIABkAGUAcgBpAHYAYQB0AGkAdgBlACAAbQBhAGQAZQAgAGIAeQAgAGEAZABkAGkAbgBnACAAdABvACwAIABkAGUAbABlAHQAaQBuAGcALAAgAG8AcgAgAHMAdQBiAHMAdABpAHQAdQB0AGkAbgBnACAALQAtACAAaQBuACAAcABhAHIAdAAgAG8AcgAgAGkAbgAgAHcAaABvAGwAZQAgAC0ALQAgAGEAbgB5ACAAbwBmACAAdABoAGUAIABjAG8AbQBwAG8AbgBlAG4AdABzACAAbwBmACAAdABoAGUAIABPAHIAaQBnAGkAbgBhAGwAIABWAGUAcgBzAGkAbwBuACwAIABiAHkAIABjAGgAYQBuAGcAaQBuAGcAIABmAG8AcgBtAGEAdABzACAAbwByACAAYgB5ACAAcABvAHIAdABpAG4AZwAgAHQAaABlACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAHQAbwAgAGEAIABuAGUAdwAgAGUAbgB2AGkAcgBvAG4AbQBlAG4AdAAuAA0ACgANAAoAIgBBAHUAdABoAG8AcgAiACAAcgBlAGYAZQByAHMAIAB0AG8AIABhAG4AeQAgAGQAZQBzAGkAZwBuAGUAcgAsACAAZQBuAGcAaQBuAGUAZQByACwAIABwAHIAbwBnAHIAYQBtAG0AZQByACwAIAB0AGUAYwBoAG4AaQBjAGEAbAAgAHcAcgBpAHQAZQByACAAbwByACAAbwB0AGgAZQByACAAcABlAHIAcwBvAG4AIAB3AGgAbwAgAGMAbwBuAHQAcgBpAGIAdQB0AGUAZAAgAHQAbwAgAHQAaABlACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAuAA0ACgANAAoAUABFAFIATQBJAFMAUwBJAE8ATgAgACYAIABDAE8ATgBEAEkAVABJAE8ATgBTAA0ACgBQAGUAcgBtAGkAcwBzAGkAbwBuACAAaQBzACAAaABlAHIAZQBiAHkAIABnAHIAYQBuAHQAZQBkACwAIABmAHIAZQBlACAAbwBmACAAYwBoAGEAcgBnAGUALAAgAHQAbwAgAGEAbgB5ACAAcABlAHIAcwBvAG4AIABvAGIAdABhAGkAbgBpAG4AZwAgAGEAIABjAG8AcAB5ACAAbwBmACAAdABoAGUAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlACwAIAB0AG8AIAB1AHMAZQAsACAAcwB0AHUAZAB5ACwAIABjAG8AcAB5ACwAIABtAGUAcgBnAGUALAAgAGUAbQBiAGUAZAAsACAAbQBvAGQAaQBmAHkALAAgAHIAZQBkAGkAcwB0AHIAaQBiAHUAdABlACwAIABhAG4AZAAgAHMAZQBsAGwAIABtAG8AZABpAGYAaQBlAGQAIABhAG4AZAAgAHUAbgBtAG8AZABpAGYAaQBlAGQAIABjAG8AcABpAGUAcwAgAG8AZgAgAHQAaABlACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAsACAAcwB1AGIAagBlAGMAdAAgAHQAbwAgAHQAaABlACAAZgBvAGwAbABvAHcAaQBuAGcAIABjAG8AbgBkAGkAdABpAG8AbgBzADoADQAKAA0ACgAxACkAIABOAGUAaQB0AGgAZQByACAAdABoAGUAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlACAAbgBvAHIAIABhAG4AeQAgAG8AZgAgAGkAdABzACAAaQBuAGQAaQB2AGkAZAB1AGEAbAAgAGMAbwBtAHAAbwBuAGUAbgB0AHMALAAgAGkAbgAgAE8AcgBpAGcAaQBuAGEAbAAgAG8AcgAgAE0AbwBkAGkAZgBpAGUAZAAgAFYAZQByAHMAaQBvAG4AcwAsACAAbQBhAHkAIABiAGUAIABzAG8AbABkACAAYgB5ACAAaQB0AHMAZQBsAGYALgANAAoADQAKADIAKQAgAE8AcgBpAGcAaQBuAGEAbAAgAG8AcgAgAE0AbwBkAGkAZgBpAGUAZAAgAFYAZQByAHMAaQBvAG4AcwAgAG8AZgAgAHQAaABlACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAG0AYQB5ACAAYgBlACAAYgB1AG4AZABsAGUAZAAsACAAcgBlAGQAaQBzAHQAcgBpAGIAdQB0AGUAZAAgAGEAbgBkAC8AbwByACAAcwBvAGwAZAAgAHcAaQB0AGgAIABhAG4AeQAgAHMAbwBmAHQAdwBhAHIAZQAsACAAcAByAG8AdgBpAGQAZQBkACAAdABoAGEAdAAgAGUAYQBjAGgAIABjAG8AcAB5ACAAYwBvAG4AdABhAGkAbgBzACAAdABoAGUAIABhAGIAbwB2AGUAIABjAG8AcAB5AHIAaQBnAGgAdAAgAG4AbwB0AGkAYwBlACAAYQBuAGQAIAB0AGgAaQBzACAAbABpAGMAZQBuAHMAZQAuACAAVABoAGUAcwBlACAAYwBhAG4AIABiAGUAIABpAG4AYwBsAHUAZABlAGQAIABlAGkAdABoAGUAcgAgAGEAcwAgAHMAdABhAG4AZAAtAGEAbABvAG4AZQAgAHQAZQB4AHQAIABmAGkAbABlAHMALAAgAGgAdQBtAGEAbgAtAHIAZQBhAGQAYQBiAGwAZQAgAGgAZQBhAGQAZQByAHMAIABvAHIAIABpAG4AIAB0AGgAZQAgAGEAcABwAHIAbwBwAHIAaQBhAHQAZQAgAG0AYQBjAGgAaQBuAGUALQByAGUAYQBkAGEAYgBsAGUAIABtAGUAdABhAGQAYQB0AGEAIABmAGkAZQBsAGQAcwAgAHcAaQB0AGgAaQBuACAAdABlAHgAdAAgAG8AcgAgAGIAaQBuAGEAcgB5ACAAZgBpAGwAZQBzACAAYQBzACAAbABvAG4AZwAgAGEAcwAgAHQAaABvAHMAZQAgAGYAaQBlAGwAZABzACAAYwBhAG4AIABiAGUAIABlAGEAcwBpAGwAeQAgAHYAaQBlAHcAZQBkACAAYgB5ACAAdABoAGUAIAB1AHMAZQByAC4ADQAKAA0ACgAzACkAIABOAG8AIABNAG8AZABpAGYAaQBlAGQAIABWAGUAcgBzAGkAbwBuACAAbwBmACAAdABoAGUAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlACAAbQBhAHkAIAB1AHMAZQAgAHQAaABlACAAUgBlAHMAZQByAHYAZQBkACAARgBvAG4AdAAgAE4AYQBtAGUAKABzACkAIAB1AG4AbABlAHMAcwAgAGUAeABwAGwAaQBjAGkAdAAgAHcAcgBpAHQAdABlAG4AIABwAGUAcgBtAGkAcwBzAGkAbwBuACAAaQBzACAAZwByAGEAbgB0AGUAZAAgAGIAeQAgAHQAaABlACAAYwBvAHIAcgBlAHMAcABvAG4AZABpAG4AZwAgAEMAbwBwAHkAcgBpAGcAaAB0ACAASABvAGwAZABlAHIALgAgAFQAaABpAHMAIAByAGUAcwB0AHIAaQBjAHQAaQBvAG4AIABvAG4AbAB5ACAAYQBwAHAAbABpAGUAcwAgAHQAbwAgAHQAaABlACAAcAByAGkAbQBhAHIAeQAgAGYAbwBuAHQAIABuAGEAbQBlACAAYQBzACAAcAByAGUAcwBlAG4AdABlAGQAIAB0AG8AIAB0AGgAZQAgAHUAcwBlAHIAcwAuAA0ACgANAAoANAApACAAVABoAGUAIABuAGEAbQBlACgAcwApACAAbwBmACAAdABoAGUAIABDAG8AcAB5AHIAaQBnAGgAdAAgAEgAbwBsAGQAZQByACgAcwApACAAbwByACAAdABoAGUAIABBAHUAdABoAG8AcgAoAHMAKQAgAG8AZgAgAHQAaABlACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAHMAaABhAGwAbAAgAG4AbwB0ACAAYgBlACAAdQBzAGUAZAAgAHQAbwAgAHAAcgBvAG0AbwB0AGUALAAgAGUAbgBkAG8AcgBzAGUAIABvAHIAIABhAGQAdgBlAHIAdABpAHMAZQAgAGEAbgB5ACAATQBvAGQAaQBmAGkAZQBkACAAVgBlAHIAcwBpAG8AbgAsACAAZQB4AGMAZQBwAHQAIAB0AG8AIABhAGMAawBuAG8AdwBsAGUAZABnAGUAIAB0AGgAZQAgAGMAbwBuAHQAcgBpAGIAdQB0AGkAbwBuACgAcwApACAAbwBmACAAdABoAGUAIABDAG8AcAB5AHIAaQBnAGgAdAAgAEgAbwBsAGQAZQByACgAcwApACAAYQBuAGQAIAB0AGgAZQAgAEEAdQB0AGgAbwByACgAcwApACAAbwByACAAdwBpAHQAaAAgAHQAaABlAGkAcgAgAGUAeABwAGwAaQBjAGkAdAAgAHcAcgBpAHQAdABlAG4AIABwAGUAcgBtAGkAcwBzAGkAbwBuAC4ADQAKAA0ACgA1ACkAIABUAGgAZQAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUALAAgAG0AbwBkAGkAZgBpAGUAZAAgAG8AcgAgAHUAbgBtAG8AZABpAGYAaQBlAGQALAAgAGkAbgAgAHAAYQByAHQAIABvAHIAIABpAG4AIAB3AGgAbwBsAGUALAAgAG0AdQBzAHQAIABiAGUAIABkAGkAcwB0AHIAaQBiAHUAdABlAGQAIABlAG4AdABpAHIAZQBsAHkAIAB1AG4AZABlAHIAIAB0AGgAaQBzACAAbABpAGMAZQBuAHMAZQAsACAAYQBuAGQAIABtAHUAcwB0ACAAbgBvAHQAIABiAGUAIABkAGkAcwB0AHIAaQBiAHUAdABlAGQAIAB1AG4AZABlAHIAIABhAG4AeQAgAG8AdABoAGUAcgAgAGwAaQBjAGUAbgBzAGUALgAgAFQAaABlACAAcgBlAHEAdQBpAHIAZQBtAGUAbgB0ACAAZgBvAHIAIABmAG8AbgB0AHMAIAB0AG8AIAByAGUAbQBhAGkAbgAgAHUAbgBkAGUAcgAgAHQAaABpAHMAIABsAGkAYwBlAG4AcwBlACAAZABvAGUAcwAgAG4AbwB0ACAAYQBwAHAAbAB5ACAAdABvACAAYQBuAHkAIABkAG8AYwB1AG0AZQBuAHQAIABjAHIAZQBhAHQAZQBkACAAdQBzAGkAbgBnACAAdABoAGUAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlAC4ADQAKAA0ACgBUAEUAUgBNAEkATgBBAFQASQBPAE4ADQAKAFQAaABpAHMAIABsAGkAYwBlAG4AcwBlACAAYgBlAGMAbwBtAGUAcwAgAG4AdQBsAGwAIABhAG4AZAAgAHYAbwBpAGQAIABpAGYAIABhAG4AeQAgAG8AZgAgAHQAaABlACAAYQBiAG8AdgBlACAAYwBvAG4AZABpAHQAaQBvAG4AcwAgAGEAcgBlACAAbgBvAHQAIABtAGUAdAAuAA0ACgANAAoARABJAFMAQwBMAEEASQBNAEUAUgANAAoAVABIAEUAIABGAE8ATgBUACAAUwBPAEYAVABXAEEAUgBFACAASQBTACAAUABSAE8AVgBJAEQARQBEACAAIgBBAFMAIABJAFMAIgAsACAAVwBJAFQASABPAFUAVAAgAFcAQQBSAFIAQQBOAFQAWQAgAE8ARgAgAEEATgBZACAASwBJAE4ARAAsACAARQBYAFAAUgBFAFMAUwAgAE8AUgAgAEkATQBQAEwASQBFAEQALAAgAEkATgBDAEwAVQBEAEkATgBHACAAQgBVAFQAIABOAE8AVAAgAEwASQBNAEkAVABFAEQAIABUAE8AIABBAE4AWQAgAFcAQQBSAFIAQQBOAFQASQBFAFMAIABPAEYAIABNAEUAUgBDAEgAQQBOAFQAQQBCAEkATABJAFQAWQAsACAARgBJAFQATgBFAFMAUwAgAEYATwBSACAAQQAgAFAAQQBSAFQASQBDAFUATABBAFIAIABQAFUAUgBQAE8AUwBFACAAQQBOAEQAIABOAE8ATgBJAE4ARgBSAEkATgBHAEUATQBFAE4AVAAgAE8ARgAgAEMATwBQAFkAUgBJAEcASABUACwAIABQAEEAVABFAE4AVAAsACAAVABSAEEARABFAE0AQQBSAEsALAAgAE8AUgAgAE8AVABIAEUAUgAgAFIASQBHAEgAVAAuACAASQBOACAATgBPACAARQBWAEUATgBUACAAUwBIAEEATABMACAAVABIAEUAIABDAE8AUABZAFIASQBHAEgAVAAgAEgATwBMAEQARQBSACAAQgBFACAATABJAEEAQgBMAEUAIABGAE8AUgAgAEEATgBZACAAQwBMAEEASQBNACwAIABEAEEATQBBAEcARQBTACAATwBSACAATwBUAEgARQBSACAATABJAEEAQgBJAEwASQBUAFkALAAgAEkATgBDAEwAVQBEAEkATgBHACAAQQBOAFkAIABHAEUATgBFAFIAQQBMACwAIABTAFAARQBDAEkAQQBMACwAIABJAE4ARABJAFIARQBDAFQALAAgAEkATgBDAEkARABFAE4AVABBAEwALAAgAE8AUgAgAEMATwBOAFMARQBRAFUARQBOAFQASQBBAEwAIABEAEEATQBBAEcARQBTACwAIABXAEgARQBUAEgARQBSACAASQBOACAAQQBOACAAQQBDAFQASQBPAE4AIABPAEYAIABDAE8ATgBUAFIAQQBDAFQALAAgAFQATwBSAFQAIABPAFIAIABPAFQASABFAFIAVwBJAFMARQAsACAAQQBSAEkAUwBJAE4ARwAgAEYAUgBPAE0ALAAgAE8AVQBUACAATwBGACAAVABIAEUAIABVAFMARQAgAE8AUgAgAEkATgBBAEIASQBMAEkAVABZACAAVABPACAAVQBTAEUAIABUAEgARQAgAEYATwBOAFQAIABTAE8ARgBUAFcAQQBSAEUAIABPAFIAIABGAFIATwBNACAATwBUAEgARQBSACAARABFAEEATABJAE4ARwBTACAASQBOACAAVABIAEUAIABGAE8ATgBUACAAUwBPAEYAVABXAEEAUgBFAC4ADQAKAGgAdAB0AHAAOgAvAC8AdwB3AHcALgBhAGQAbwBiAGUALgBjAG8AbQAvAHQAeQBwAGUALwBsAGUAZwBhAGwALgBoAHQAbQBsAAAAAAAFAAAAAwAAADgAAAAEAAABUAABAAAAAAAsAAMAAQAAADgAAwAKAAABUAAGAAwAAAAAAAEAAAAEARgAAABCAEAABQACB/8P/xf/H/8n/y//N/8//0f/T/9X/1//Z/9v/3f/f/+H/4//l/+f/6f/r/+3/7//x//P/9f/5//v//f//c///f//AAAAAAgAEAAYACAAKAAwADgAQABIAFAAWABgAGgAcAB4AIAAiACQAJgAoACoALAAuADAAMgA0ADgAOgA8AD4AP3w//8AAfgB8AHoAeAB2AHQAcgBwAG4AbABqAGgAZgBkAGIAYABeAFwAWgBYAFYAVABSAFAATgBMAEgARgBEAEIAQgBAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAZkAAAAAAAAAIgAAAAAAAAB/8AAAABAAAIAAAAD/8AAAABAAAQAAAAF/8AAAABAAAYAAAAH/8AAAABAAAgAAAAJ/8AAAABAAAoAAAAL/8AAAABAAAwAAAAN/8AAAABAAA4AAAAP/8AAAABAABAAAAAR/8AAAABAABIAAAAT/8AAAABAABQAAAAV/8AAAABAABYAAAAX/8AAAABAABgAAAAZ/8AAAABAABoAAAAb/8AAAABAABwAAAAd/8AAAABAAB4AAAAf/8AAAABAACAAAAAh/8AAAABAACIAAAAj/8AAAABAACQAAAAl/8AAAABAACYAAAAn/8AAAABAACgAAAAp/8AAAABAACoAAAAr/8AAAABAACwAAAAt/8AAAABAAC4AAAAv/8AAAABAADAAAAAx/8AAAABAADIAAAAz/8AAAABAADQAAAA1/8AAAABAADgAAAA5/8AAAABAADoAAAA7/8AAAABAADwAAAA9/8AAAABAAD4AAAA/c8AAAABAAD98AAA//0AAAXxAAEAAAABB/8AAAABAAEIAAABD/8AAAABAAEQAAABF/8AAAABAAEYAAABH/8AAAABAAEgAAABJ/8AAAABAAEoAAABL/8AAAABAAEwAAABN/8AAAABAAE4AAABP/8AAAABAAFAAAABR/8AAAABAAFIAAABT/8AAAABAAFQAAABV/8AAAABAAFYAAABX/8AAAABAAFgAAABZ/8AAAABAAFoAAABb/8AAAABAAFwAAABd/8AAAABAAF4AAABf/8AAAABAAGAAAABh/8AAAABAAGIAAABj/8AAAABAAGQAAABl/8AAAABAAGYAAABn/8AAAABAAGgAAABp/8AAAABAAGoAAABr/8AAAABAAGwAAABt/8AAAABAAG4AAABv/8AAAABAAHAAAABx/8AAAABAAHIAAABz/8AAAABAAHQAAAB1/8AAAABAAHYAAAB3/8AAAABAAHgAAAB5/8AAAABAAHoAAAB7/8AAAABAAHwAAAB9/8AAAABAAH4AAAB//0AAAABAAIAAAACB/8AAAABAAIIAAACD/8AAAABAAIQAAACF/8AAAABAAIYAAACH/8AAAABAAIgAAACJ/8AAAABAAIoAAACL/8AAAABAAIwAAACN/8AAAABAAI4AAACP/8AAAABAAJAAAACR/8AAAABAAJIAAACT/8AAAABAAJQAAACV/8AAAABAAJYAAACX/8AAAABAAJgAAACZ/8AAAABAAJoAAACb/8AAAABAAJwAAACd/8AAAABAAJ4AAACf/8AAAABAAKAAAACh/8AAAABAAKIAAACj/8AAAABAAKQAAACl/8AAAABAAKYAAACn/8AAAABAAKgAAACp/8AAAABAAKoAAACr/8AAAABAAKwAAACt/8AAAABAAK4AAACv/8AAAABAALAAAACx/8AAAABAALIAAACz/8AAAABAALQAAAC1/8AAAABAALYAAAC3/8AAAABAALgAAAC5/8AAAABAALoAAAC7/8AAAABAALwAAAC9/8AAAABAAL4AAAC//0AAAABAAMAAAADB/8AAAABAAMIAAADD/8AAAABAAMQAAADF/8AAAABAAMYAAADH/8AAAABAAMgAAADJ/8AAAABAAMoAAADL/8AAAABAAMwAAADN/8AAAABAAM4AAADP/8AAAABAANAAAADR/8AAAABAANIAAADT/8AAAABAANQAAADV/8AAAABAANYAAADX/8AAAABAANgAAADZ/8AAAABAANoAAADb/8AAAABAANwAAADd/8AAAABAAN4AAADf/8AAAABAAOAAAADh/8AAAABAAOIAAADj/8AAAABAAOQAAADl/8AAAABAAOYAAADn/8AAAABAAOgAAADp/8AAAABAAOoAAADr/8AAAABAAOwAAADt/8AAAABAAO4AAADv/8AAAABAAPAAAADx/8AAAABAAPIAAADz/8AAAABAAPQAAAD1/8AAAABAAPYAAAD3/8AAAABAAPgAAAD5/8AAAABAAPoAAAD7/8AAAABAAPwAAAD9/8AAAABAAP4AAAD//0AAAABAAQAAAAEB/8AAAABAAQIAAAED/8AAAABAAQQAAAEF/8AAAABAAQYAAAEH/8AAAABAAQgAAAEJ/8AAAABAAQoAAAEL/8AAAABAAQwAAAEN/8AAAABAAQ4AAAEP/8AAAABAARAAAAER/8AAAABAARIAAAET/8AAAABAARQAAAEV/8AAAABAARYAAAEX/8AAAABAARgAAAEZ/8AAAABAARoAAAEb/8AAAABAARwAAAEd/8AAAABAAR4AAAEf/8AAAABAASAAAAEh/8AAAABAASIAAAEj/8AAAABAASQAAAEl/8AAAABAASYAAAEn/8AAAABAASgAAAEp/8AAAABAASoAAAEr/8AAAABAASwAAAEt/8AAAABAAS4AAAEv/8AAAABAATAAAAEx/8AAAABAATIAAAEz/8AAAABAATQAAAE1/8AAAABAATYAAAE3/8AAAABAATgAAAE5/8AAAABAAToAAAE7/8AAAABAATwAAAE9/8AAAABAAT4AAAE//0AAAABAAUAAAAFB/8AAAABAAUIAAAFD/8AAAABAAUQAAAFF/8AAAABAAUYAAAFH/8AAAABAAUgAAAFJ/8AAAABAAUoAAAFL/8AAAABAAUwAAAFN/8AAAABAAU4AAAFP/8AAAABAAVAAAAFR/8AAAABAAVIAAAFT/8AAAABAAVQAAAFV/8AAAABAAVYAAAFX/8AAAABAAVgAAAFZ/8AAAABAAVoAAAFb/8AAAABAAVwAAAFd/8AAAABAAV4AAAFf/8AAAABAAWAAAAFh/8AAAABAAWIAAAFj/8AAAABAAWQAAAFl/8AAAABAAWYAAAFn/8AAAABAAWgAAAFp/8AAAABAAWoAAAFr/8AAAABAAWwAAAFt/8AAAABAAW4AAAFv/8AAAABAAXAAAAFx/8AAAABAAXIAAAFz/8AAAABAAXQAAAF1/8AAAABAAXYAAAF3/8AAAABAAXgAAAF5/8AAAABAAXoAAAF7/8AAAABAAXwAAAF9/8AAAABAAX4AAAF//0AAAABAAYAAAAGB/8AAAABAAYIAAAGD/8AAAABAAYQAAAGF/8AAAABAAYYAAAGH/8AAAABAAYgAAAGJ/8AAAABAAYoAAAGL/8AAAABAAYwAAAGN/8AAAABAAY4AAAGP/8AAAABAAZAAAAGR/8AAAABAAZIAAAGT/8AAAABAAZQAAAGV/8AAAABAAZYAAAGX/8AAAABAAZgAAAGZ/8AAAABAAZoAAAGb/8AAAABAAZwAAAGd/8AAAABAAZ4AAAGf/8AAAABAAaAAAAGh/8AAAABAAaIAAAGj/8AAAABAAaQAAAGl/8AAAABAAaYAAAGn/8AAAABAAagAAAGp/8AAAABAAaoAAAGr/8AAAABAAawAAAGt/8AAAABAAa4AAAGv/8AAAABAAbAAAAGx/8AAAABAAbIAAAGz/8AAAABAAbQAAAG1/8AAAABAAbYAAAG3/8AAAABAAbgAAAG5/8AAAABAAboAAAG7/8AAAABAAbwAAAG9/8AAAABAAb4AAAG//0AAAABAAcAAAAHB/8AAAABAAcIAAAHD/8AAAABAAcQAAAHF/8AAAABAAcYAAAHH/8AAAABAAcgAAAHJ/8AAAABAAcoAAAHL/8AAAABAAcwAAAHN/8AAAABAAc4AAAHP/8AAAABAAdAAAAHR/8AAAABAAdIAAAHT/8AAAABAAdQAAAHV/8AAAABAAdYAAAHX/8AAAABAAdgAAAHZ/8AAAABAAdoAAAHb/8AAAABAAdwAAAHd/8AAAABAAd4AAAHf/8AAAABAAeAAAAHh/8AAAABAAeIAAAHj/8AAAABAAeQAAAHl/8AAAABAAeYAAAHn/8AAAABAAegAAAHp/8AAAABAAeoAAAHr/8AAAABAAewAAAHt/8AAAABAAe4AAAHv/8AAAABAAfAAAAHx/8AAAABAAfIAAAHz/8AAAABAAfQAAAH1/8AAAABAAfYAAAH3/8AAAABAAfgAAAH5/8AAAABAAfoAAAH7/8AAAABAAfwAAAH9/8AAAABAAf4AAAH//0AAAABAAgAAAAIB/8AAAABAAgIAAAID/8AAAABAAgQAAAIF/8AAAABAAgYAAAIH/8AAAABAAggAAAIJ/8AAAABAAgoAAAIL/8AAAABAAgwAAAIN/8AAAABAAg4AAAIP/8AAAABAAhAAAAIR/8AAAABAAhIAAAIT/8AAAABAAhQAAAIV/8AAAABAAhYAAAIX/8AAAABAAhgAAAIZ/8AAAABAAhoAAAIb/8AAAABAAhwAAAId/8AAAABAAh4AAAIf/8AAAABAAiAAAAIh/8AAAABAAiIAAAIj/8AAAABAAiQAAAIl/8AAAABAAiYAAAIn/8AAAABAAigAAAIp/8AAAABAAioAAAIr/8AAAABAAiwAAAIt/8AAAABAAi4AAAIv/8AAAABAAjAAAAIx/8AAAABAAjIAAAIz/8AAAABAAjQAAAI1/8AAAABAAjYAAAI3/8AAAABAAjgAAAI5/8AAAABAAjoAAAI7/8AAAABAAjwAAAI9/8AAAABAAj4AAAI//0AAAABAAkAAAAJB/8AAAABAAkIAAAJD/8AAAABAAkQAAAJF/8AAAABAAkYAAAJH/8AAAABAAkgAAAJJ/8AAAABAAkoAAAJL/8AAAABAAkwAAAJN/8AAAABAAk4AAAJP/8AAAABAAlAAAAJR/8AAAABAAlIAAAJT/8AAAABAAlQAAAJV/8AAAABAAlYAAAJX/8AAAABAAlgAAAJZ/8AAAABAAloAAAJb/8AAAABAAlwAAAJd/8AAAABAAl4AAAJf/8AAAABAAmAAAAJh/8AAAABAAmIAAAJj/8AAAABAAmQAAAJl/8AAAABAAmYAAAJn/8AAAABAAmgAAAJp/8AAAABAAmoAAAJr/8AAAABAAmwAAAJt/8AAAABAAm4AAAJv/8AAAABAAnAAAAJx/8AAAABAAnIAAAJz/8AAAABAAnQAAAJ1/8AAAABAAnYAAAJ3/8AAAABAAngAAAJ5/8AAAABAAnoAAAJ7/8AAAABAAnwAAAJ9/8AAAABAAn4AAAJ//0AAAABAAoAAAAKB/8AAAABAAoIAAAKD/8AAAABAAoQAAAKF/8AAAABAAoYAAAKH/8AAAABAAogAAAKJ/8AAAABAAooAAAKL/8AAAABAAowAAAKN/8AAAABAAo4AAAKP/8AAAABAApAAAAKR/8AAAABAApIAAAKT/8AAAABAApQAAAKV/8AAAABAApYAAAKX/8AAAABAApgAAAKZ/8AAAABAApoAAAKb/8AAAABAApwAAAKd/8AAAABAAp4AAAKf/8AAAABAAqAAAAKh/8AAAABAAqIAAAKj/8AAAABAAqQAAAKl/8AAAABAAqYAAAKn/8AAAABAAqgAAAKp/8AAAABAAqoAAAKr/8AAAABAAqwAAAKt/8AAAABAAq4AAAKv/8AAAABAArAAAAKx/8AAAABAArIAAAKz/8AAAABAArQAAAK1/8AAAABAArYAAAK3/8AAAABAArgAAAK5/8AAAABAAroAAAK7/8AAAABAArwAAAK9/8AAAABAAr4AAAK//0AAAABAAsAAAALB/8AAAABAAsIAAALD/8AAAABAAsQAAALF/8AAAABAAsYAAALH/8AAAABAAsgAAALJ/8AAAABAAsoAAALL/8AAAABAAswAAALN/8AAAABAAs4AAALP/8AAAABAAtAAAALR/8AAAABAAtIAAALT/8AAAABAAtQAAALV/8AAAABAAtYAAALX/8AAAABAAtgAAALZ/8AAAABAAtoAAALb/8AAAABAAtwAAALd/8AAAABAAt4AAALf/8AAAABAAuAAAALh/8AAAABAAuIAAALj/8AAAABAAuQAAALl/8AAAABAAuYAAALn/8AAAABAAugAAALp/8AAAABAAuoAAALr/8AAAABAAuwAAALt/8AAAABAAu4AAALv/8AAAABAAvAAAALx/8AAAABAAvIAAALz/8AAAABAAvQAAAL1/8AAAABAAvYAAAL3/8AAAABAAvgAAAL5/8AAAABAAvoAAAL7/8AAAABAAvwAAAL9/8AAAABAAv4AAAL//0AAAABAAwAAAAMB/8AAAABAAwIAAAMD/8AAAABAAwQAAAMF/8AAAABAAwYAAAMH/8AAAABAAwgAAAMJ/8AAAABAAwoAAAML/8AAAABAAwwAAAMN/8AAAABAAw4AAAMP/8AAAABAAxAAAAMR/8AAAABAAxIAAAMT/8AAAABAAxQAAAMV/8AAAABAAxYAAAMX/8AAAABAAxgAAAMZ/8AAAABAAxoAAAMb/8AAAABAAxwAAAMd/8AAAABAAx4AAAMf/8AAAABAAyAAAAMh/8AAAABAAyIAAAMj/8AAAABAAyQAAAMl/8AAAABAAyYAAAMn/8AAAABAAygAAAMp/8AAAABAAyoAAAMr/8AAAABAAywAAAMt/8AAAABAAy4AAAMv/8AAAABAAzAAAAMx/8AAAABAAzIAAAMz/8AAAABAAzQAAAM1/8AAAABAAzYAAAM3/8AAAABAAzgAAAM5/8AAAABAAzoAAAM7/8AAAABAAzwAAAM9/8AAAABAAz4AAAM//0AAAABAA0AAAANB/8AAAABAA0IAAAND/8AAAABAA0QAAANF/8AAAABAA0YAAANH/8AAAABAA0gAAANJ/8AAAABAA0oAAANL/8AAAABAA0wAAANN/8AAAABAA04AAANP/8AAAABAA1AAAANR/8AAAABAA1IAAANT/8AAAABAA1QAAANV/8AAAABAA1YAAANX/8AAAABAA1gAAANZ/8AAAABAA1oAAANb/8AAAABAA1wAAANd/8AAAABAA14AAANf/8AAAABAA2AAAANh/8AAAABAA2IAAANj/8AAAABAA2QAAANl/8AAAABAA2YAAANn/8AAAABAA2gAAANp/8AAAABAA2oAAANr/8AAAABAA2wAAANt/8AAAABAA24AAANv/8AAAABAA3AAAANx/8AAAABAA3IAAANz/8AAAABAA3QAAAN1/8AAAABAA3YAAAN3/8AAAABAA3gAAAN5/8AAAABAA3oAAAN7/8AAAABAA3wAAAN9/8AAAABAA34AAAN//0AAAABAA4AAAAOB/8AAAABAA4IAAAOD/8AAAABAA4QAAAOF/8AAAABAA4YAAAOH/8AAAABAA4gAAAOJ/8AAAABAA4oAAAOL/8AAAABAA4wAAAON/8AAAABAA44AAAOP/8AAAABAA5AAAAOR/8AAAABAA5IAAAOT/8AAAABAA5QAAAOV/8AAAABAA5YAAAOX/8AAAABAA5gAAAOZ/8AAAABAA5oAAAOb/8AAAABAA5wAAAOd/8AAAABAA54AAAOf/8AAAABAA6AAAAOh/8AAAABAA6IAAAOj/8AAAABAA6QAAAOl/8AAAABAA6YAAAOn/8AAAABAA6gAAAOp/8AAAABAA6oAAAOr/8AAAABAA6wAAAOt/8AAAABAA64AAAOv/8AAAABAA7AAAAOx/8AAAABAA7IAAAOz/8AAAABAA7QAAAO1/8AAAABAA7YAAAO3/8AAAABAA7gAAAO5/8AAAABAA7oAAAO7/8AAAABAA7wAAAO9/8AAAABAA74AAAO//0AAAABAA8AAAAPB/8AAAABAA8IAAAPD/8AAAABAA8QAAAPF/8AAAABAA8YAAAPH/8AAAABAA8gAAAPJ/8AAAABAA8oAAAPL/8AAAABAA8wAAAPN/8AAAABAA84AAAPP/8AAAABAA9AAAAPR/8AAAABAA9IAAAPT/8AAAABAA9QAAAPV/8AAAABAA9YAAAPX/8AAAABAA9gAAAPZ/8AAAABAA9oAAAPb/8AAAABAA9wAAAPd/8AAAABAA94AAAPf/8AAAABAA+AAAAPh/8AAAABAA+IAAAPj/8AAAABAA+QAAAPl/8AAAABAA+YAAAPn/8AAAABAA+gAAAPp/8AAAABAA+oAAAPr/8AAAABAA+wAAAPt/8AAAABAA+4AAAPv/8AAAABAA/AAAAPx/8AAAABAA/IAAAPz/8AAAABAA/QAAAP1/8AAAABAA/YAAAP3/8AAAABAA/gAAAP5/8AAAABAA/oAAAP7/8AAAABAA/wAAAP9/8AAAABAA/4AAAP//0AAAABABAAAAAQB/8AAAABABAIAAAQD/8AAAABABAQAAAQF/8AAAABABAYAAAQH/8AAAABABAgAAAQJ/8AAAABABAoAAAQL/8AAAABABAwAAAQN/8AAAABABA4AAAQP/8AAAABABBAAAAQR/8AAAABABBIAAAQT/8AAAABABBQAAAQV/8AAAABABBYAAAQX/8AAAABABBgAAAQZ/8AAAABABBoAAAQb/8AAAABABBwAAAQd/8AAAABABB4AAAQf/8AAAABABCAAAAQh/8AAAABABCIAAAQj/8AAAABABCQAAAQl/8AAAABABCYAAAQn/8AAAABABCgAAAQp/8AAAABABCoAAAQr/8AAAABABCwAAAQt/8AAAABABC4AAAQv/8AAAABABDAAAAQx/8AAAABABDIAAAQz/8AAAABABDQAAAQ1/8AAAABABDYAAAQ3/8AAAABABDgAAAQ5/8AAAABABDoAAAQ7/8AAAABABDwAAAQ9/8AAAABABD4AAAQ//0AAAABAAMAAAAAAAD/tQAyAAAAAAAAAAAAAAAAAAAAAAAAAAABAAQCAAEBAQtBZG9iZUJsYW5rAAEBATD4G/gciwwe+B0B+B4Ci/sM+gD6BAUeGgA/DB8cCAEMIvdMD/dZEfdRDCUcGRYMJAAFAQEGDk1YZ0Fkb2JlSWRlbnRpdHlDb3B5cmlnaHQgMjAxMyBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5BZG9iZSBCbGFua0Fkb2JlQmxhbmstMjA0OQAAAgABB/8DAAEAAAAIAQgBAgABAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQBiAGMAZABlAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAcwB0AHUAdgB3AHgAeQB6AHsAfAB9AH4AfwCAAIEAggCDAIQAhQCGAIcAiACJAIoAiwCMAI0AjgCPAJAAkQCSAJMAlACVAJYAlwCYAJkAmgCbAJwAnQCeAJ8AoAChAKIAowCkAKUApgCnAKgAqQCqAKsArACtAK4ArwCwALEAsgCzALQAtQC2ALcAuAC5ALoAuwC8AL0AvgC/AMAAwQDCAMMAxADFAMYAxwDIAMkAygDLAMwAzQDOAM8A0ADRANIA0wDUANUA1gDXANgA2QDaANsA3ADdAN4A3wDgAOEA4gDjAOQA5QDmAOcA6ADpAOoA6wDsAO0A7gDvAPAA8QDyAPMA9AD1APYA9wD4APkA+gD7APwA/QD+AP8BAAEBAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfASABIQEiASMBJAElASYBJwEoASkBKgErASwBLQEuAS8BMAExATIBMwE0ATUBNgE3ATgBOQE6ATsBPAE9AT4BPwFAAUEBQgFDAUQBRQFGAUcBSAFJAUoBSwFMAU0BTgFPAVABUQFSAVMBVAFVAVYBVwFYAVkBWgFbAVwBXQFeAV8BYAFhAWIBYwFkAWUBZgFnAWgBaQFqAWsBbAFtAW4BbwFwAXEBcgFzAXQBdQF2AXcBeAF5AXoBewF8AX0BfgF/AYABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwG4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gHfAeAB4QHiAeMB5AHlAeYB5wHoAekB6gHrAewB7QHuAe8B8AHxAfIB8wH0AfUB9gH3AfgB+QH6AfsB/AH9Af4B/wIAAgECAgIDAgQCBQIGAgcCCAIJAgoCCwIMAg0CDgIPAhACEQISAhMCFAIVAhYCFwIYAhkCGgIbAhwCHQIeAh8CIAIhAiICIwIkAiUCJgInAigCKQIqAisCLAItAi4CLwIwAjECMgIzAjQCNQI2AjcCOAI5AjoCOwI8Aj0CPgI/AkACQQJCAkMCRAJFAkYCRwJIAkkCSgJLAkwCTQJOAk8CUAJRAlICUwJUAlUCVgJXAlgCWQJaAlsCXAJdAl4CXwJgAmECYgJjAmQCZQJmAmcCaAJpAmoCawJsAm0CbgJvAnACcQJyAnMCdAJ1AnYCdwJ4AnkCegJ7AnwCfQJ+An8CgAKBAoICgwKEAoUChgKHAogCiQKKAosCjAKNAo4CjwKQApECkgKTApQClQKWApcCmAKZApoCmwKcAp0CngKfAqACoQKiAqMCpAKlAqYCpwKoAqkCqgKrAqwCrQKuAq8CsAKxArICswK0ArUCtgK3ArgCuQK6ArsCvAK9Ar4CvwLAAsECwgLDAsQCxQLGAscCyALJAsoCywLMAs0CzgLPAtAC0QLSAtMC1ALVAtYC1wLYAtkC2gLbAtwC3QLeAt8C4ALhAuIC4wLkAuUC5gLnAugC6QLqAusC7ALtAu4C7wLwAvEC8gLzAvQC9QL2AvcC+AL5AvoC+wL8Av0C/gL/AwADAQMCAwMDBAMFAwYDBwMIAwkDCgMLAwwDDQMOAw8DEAMRAxIDEwMUAxUDFgMXAxgDGQMaAxsDHAMdAx4DHwMgAyEDIgMjAyQDJQMmAycDKAMpAyoDKwMsAy0DLgMvAzADMQMyAzMDNAM1AzYDNwM4AzkDOgM7AzwDPQM+Az8DQANBA0IDQwNEA0UDRgNHA0gDSQNKA0sDTANNA04DTwNQA1EDUgNTA1QDVQNWA1cDWANZA1oDWwNcA10DXgNfA2ADYQNiA2MDZANlA2YDZwNoA2kDagNrA2wDbQNuA28DcANxA3IDcwN0A3UDdgN3A3gDeQN6A3sDfAN9A34DfwOAA4EDggODA4QDhQOGA4cDiAOJA4oDiwOMA40DjgOPA5ADkQOSA5MDlAOVA5YDlwOYA5kDmgObA5wDnQOeA58DoAOhA6IDowOkA6UDpgOnA6gDqQOqA6sDrAOtA64DrwOwA7EDsgOzA7QDtQO2A7cDuAO5A7oDuwO8A70DvgO/A8ADwQPCA8MDxAPFA8YDxwPIA8kDygPLA8wDzQPOA88D0APRA9ID0wPUA9UD1gPXA9gD2QPaA9sD3APdA94D3wPgA+ED4gPjA+QD5QPmA+cD6APpA+oD6wPsA+0D7gPvA/AD8QPyA/MD9AP1A/YD9wP4A/kD+gP7A/wD/QP+A/8EAAQBBAIEAwQEBAUEBgQHBAgECQQKBAsEDAQNBA4EDwQQBBEEEgQTBBQEFQQWBBcEGAQZBBoEGwQcBB0EHgQfBCAEIQQiBCMEJAQlBCYEJwQoBCkEKgQrBCwELQQuBC8EMAQxBDIEMwQ0BDUENgQ3BDgEOQQ6BDsEPAQ9BD4EPwRABEEEQgRDBEQERQRGBEcESARJBEoESwRMBE0ETgRPBFAEUQRSBFMEVARVBFYEVwRYBFkEWgRbBFwEXQReBF8EYARhBGIEYwRkBGUEZgRnBGgEaQRqBGsEbARtBG4EbwRwBHEEcgRzBHQEdQR2BHcEeAR5BHoEewR8BH0EfgR/BIAEgQSCBIMEhASFBIYEhwSIBIkEigSLBIwEjQSOBI8EkASRBJIEkwSUBJUElgSXBJgEmQSaBJsEnASdBJ4EnwSgBKEEogSjBKQEpQSmBKcEqASpBKoEqwSsBK0ErgSvBLAEsQSyBLMEtAS1BLYEtwS4BLkEugS7BLwEvQS+BL8EwATBBMIEwwTEBMUExgTHBMgEyQTKBMsEzATNBM4EzwTQBNEE0gTTBNQE1QTWBNcE2ATZBNoE2wTcBN0E3gTfBOAE4QTiBOME5ATlBOYE5wToBOkE6gTrBOwE7QTuBO8E8ATxBPIE8wT0BPUE9gT3BPgE+QT6BPsE/AT9BP4E/wUABQEFAgUDBQQFBQUGBQcFCAUJBQoFCwUMBQ0FDgUPBRAFEQUSBRMFFAUVBRYFFwUYBRkFGgUbBRwFHQUeBR8FIAUhBSIFIwUkBSUFJgUnBSgFKQUqBSsFLAUtBS4FLwUwBTEFMgUzBTQFNQU2BTcFOAU5BToFOwU8BT0FPgU/BUAFQQVCBUMFRAVFBUYFRwVIBUkFSgVLBUwFTQVOBU8FUAVRBVIFUwVUBVUFVgVXBVgFWQVaBVsFXAVdBV4FXwVgBWEFYgVjBWQFZQVmBWcFaAVpBWoFawVsBW0FbgVvBXAFcQVyBXMFdAV1BXYFdwV4BXkFegV7BXwFfQV+BX8FgAWBBYIFgwWEBYUFhgWHBYgFiQWKBYsFjAWNBY4FjwWQBZEFkgWTBZQFlQWWBZcFmAWZBZoFmwWcBZ0FngWfBaAFoQWiBaMFpAWlBaYFpwWoBakFqgWrBawFrQWuBa8FsAWxBbIFswW0BbUFtgW3BbgFuQW6BbsFvAW9Bb4FvwXABcEFwgXDBcQFxQXGBccFyAXJBcoFywXMBc0FzgXPBdAF0QXSBdMF1AXVBdYF1wXYBdkF2gXbBdwF3QXeBd8F4AXhBeIF4wXkBeUF5gXnBegF6QXqBesF7AXtBe4F7wXwBfEF8gXzBfQF9QX2BfcF+AX5BfoF+wX8Bf0F/gX/BgAGAQYCBgMGBAYFBgYGBwYIBgkGCgYLBgwGDQYOBg8GEAYRBhIGEwYUBhUGFgYXBhgGGQYaBhsGHAYdBh4GHwYgBiEGIgYjBiQGJQYmBicGKAYpBioGKwYsBi0GLgYvBjAGMQYyBjMGNAY1BjYGNwY4BjkGOgY7BjwGPQY+Bj8GQAZBBkIGQwZEBkUGRgZHBkgGSQZKBksGTAZNBk4GTwZQBlEGUgZTBlQGVQZWBlcGWAZZBloGWwZcBl0GXgZfBmAGYQZiBmMGZAZlBmYGZwZoBmkGagZrBmwGbQZuBm8GcAZxBnIGcwZ0BnUGdgZ3BngGeQZ6BnsGfAZ9Bn4GfwaABoEGggaDBoQGhQaGBocGiAaJBooGiwaMBo0GjgaPBpAGkQaSBpMGlAaVBpYGlwaYBpkGmgabBpwGnQaeBp8GoAahBqIGowakBqUGpganBqgGqQaqBqsGrAatBq4GrwawBrEGsgazBrQGtQa2BrcGuAa5BroGuwa8Br0Gvga/BsAGwQbCBsMGxAbFBsYGxwbIBskGygbLBswGzQbOBs8G0AbRBtIG0wbUBtUG1gbXBtgG2QbaBtsG3AbdBt4G3wbgBuEG4gbjBuQG5QbmBucG6AbpBuoG6wbsBu0G7gbvBvAG8QbyBvMG9Ab1BvYG9wb4BvkG+gb7BvwG/Qb+Bv8HAAcBBwIHAwcEBwUHBgcHBwgHCQcKBwsHDAcNBw4HDwcQBxEHEgcTBxQHFQcWBxcHGAcZBxoHGwccBx0HHgcfByAHIQciByMHJAclByYHJwcoBykHKgcrBywHLQcuBy8HMAcxBzIHMwc0BzUHNgc3BzgHOQc6BzsHPAc9Bz4HPwdAB0EHQgdDB0QHRQdGB0cHSAdJB0oHSwdMB00HTgdPB1AHUQdSB1MHVAdVB1YHVwdYB1kHWgdbB1wHXQdeB18HYAdhB2IHYwdkB2UHZgdnB2gHaQdqB2sHbAdtB24HbwdwB3EHcgdzB3QHdQd2B3cHeAd5B3oHewd8B30Hfgd/B4AHgQeCB4MHhAeFB4YHhweIB4kHigeLB4wHjQeOB48HkAeRB5IHkweUB5UHlgeXB5gHmQeaB5sHnAedB54HnwegB6EHogejB6QHpQemB6cHqAepB6oHqwesB60HrgevB7AHsQeyB7MHtAe1B7YHtwe4B7kHuge7B7wHvQe+B78HwAfBB8IHwwfEB8UHxgfHB8gHyQfKB8sHzAfNB84HzwfQB9EH0gfTB9QH1QfWB9cH2AfZB9oH2wfcB90H3gffB+AH4QfiB+MH5AflB+YH5wfoB+kH6gfrB+wH7QfuB+8H8AfxB/IH8wf0B/UH9gf3B/gH+Qf6B/sH/Af9B/4H/wgACAEIAggDCAQIBQgGCAcICAgJCAoICwgMCA0IDggPCBAIEQgSCBMIFAgVCBYIFwgYCBkIGggbCBwIHQgeCB8IIAghCCIIIwgkCCUIJggnCCgIKQgqCCsILAgtCC4ILwgwCDEIMggzCDQINQg2CDcIOAg5CDoIOwg8CD0IPgg/CEAIQQhCCEMIRAhFCEYIRwhICEkISghLIPsMt/oktwH3ELf5LLcD9xD6BBX+fPmE+nwH/Vj+JxX50gf3xfwzBaawFfvF+DcF+PYGpmIV/dIH+8X4MwVwZhX3xfw3Bfz2Bg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODgABAQEK+B8MJpocGSQS+46LHAVGiwa9Cr0L+ucVAAPoAHwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAA') format('truetype'); }";
  FontLoader.fontStyleAliasesMap = {"n": "normal", "b": "bold", "i": "italic", "o": "oblique"};
  FontLoader.fontStretchAliasesMap = {"a": "ultra-condensed", "b": "extra-condensed", "c": "condensed", "d": "semi-condensed", "n": "normal", "e": "semi-expanded", "f": "expanded", "g": "extra-expanded", "h": "ultra-expanded"};

  FontLoader.prototype = {
    constructor: FontLoader,
    loadFonts: function() {
      var self = this,
          newFontVariations;

      if (this._started) {
        throw new Error("FontLoader: loadFonts can not be called twice. Create new FontLoader to load different fonts.");
      }
      this._started = true;

      if (this._numberOfFonts === 0) {
        this._finish();
        return;
      }

      if (this.timeout !== null) {
        this._timeoutId = window.setTimeout(function timeoutFire() {
          self._finish();
        }, this.timeout);
      }

      // Use constant line-height so there won't be changes in height because Adobe Blank uses zero width but not zero height.
      this._testContainer = this._document.createElement("div");
      this._testContainer.style.cssText = "position:absolute; left:-10000px; top:-10000px; white-space:nowrap; font-size:20px; line-height:20px; visibility:hidden;";

      // Create testDiv template that will be cloned for each font
      this._testDiv = this._document.createElement("div");
      this._testDiv.style.position = "absolute";
      this._testDiv.appendChild(this._document.createTextNode(FontLoader.referenceText));

      if (!FontLoader.useAdobeBlank) {
        // AdobeBlank is not used
        // We need to extract dimensions of reference font-families for each requested font variation.
        // The extracted dimensions are stored in a static property "referenceFontFamilyVariationSizes",
        // so we might already have some or all of them all.
        newFontVariations = this._getNewFontVariationsFromFonts(this._fontsArray);
        if (newFontVariations.length) {
          this._extractReferenceFontSizes(newFontVariations);
        }
        this._loadFonts();
      } else if (FontLoader.adobeBlankReferenceSize) {
        // AdobeBlank is used, and was loaded
        this._loadFonts();
      } else {
        // AdobeBlank is used but was not loaded
        this._loadAdobeBlankFont();
      }
    },
    _extractReferenceFontSizes: function(newFontVariations) {
      var clonedDiv, j, i,
          key, size, fontVariation;

      clonedDiv = this._testDiv.cloneNode(true);
      this._testContainer.appendChild(clonedDiv);
      this._document.body.appendChild(this._testContainer);

      for (i = 0; i < newFontVariations.length; i++) {
        fontVariation = newFontVariations[i];
        key = fontVariation.key;
        FontLoader.referenceFontFamilyVariationSizes[key] = [];
        for (j = 0; j < FontLoader.referenceFontFamilies.length; j++) {
          clonedDiv.style.fontFamily = FontLoader.referenceFontFamilies[j];
          clonedDiv.style.fontWeight = fontVariation.weight;
          clonedDiv.style.fontStyle = fontVariation.style;
          clonedDiv.style.fontStretch = fontVariation.stretch;
          size = new Size(clonedDiv.offsetWidth, clonedDiv.offsetHeight);
          FontLoader.referenceFontFamilyVariationSizes[key].push(size);
        }
      }

      this._testContainer.parentNode.removeChild(this._testContainer);
      clonedDiv.parentNode.removeChild(clonedDiv);
    },
    _loadAdobeBlankFont: function() {
      var self = this,
          adobeBlankDiv,
          adobeBlankFallbackFont = "serif";

      this._addAdobeBlankFontFaceIfNeeded();

      adobeBlankDiv = this._testDiv.cloneNode(true);
      this._testContainer.appendChild(adobeBlankDiv);
      this._document.body.appendChild(this._testContainer);

      // When using AdobeBlank (all browsers except IE < 11) only interval checking and size watcher methods
      // are available for watching element size.
      if (FontLoader.useIntervalChecking) {
        adobeBlankDiv.style.fontFamily = FontLoader.referenceFontFamilies[0] + ", " + adobeBlankFallbackFont;
        this._testContainer.appendChild(adobeBlankDiv);
        // Start polling element sizes but also do first synchronous check in case all fonts where already loaded.
        this._intervalId = window.setInterval(function intervalFire() {
          self._checkAdobeBlankSize();
        }, this._intervalDelay);
        this._checkAdobeBlankSize();
      } else {
        adobeBlankDiv.style.fontFamily = adobeBlankFallbackFont;
        this._adobeBlankSizeWatcher = new SizeWatcher(/** @type HTMLElement */adobeBlankDiv, {
          container: this._testContainer,
          delegate: this,
          continuous: true,
          direction: SizeWatcher.directions.decrease,
          dimension: SizeWatcher.dimensions.horizontal,
          document: this._document
        });
        this._adobeBlankSizeWatcher.prepareForWatch();
        this._adobeBlankSizeWatcher.beginWatching();
        adobeBlankDiv.style.fontFamily = FontLoader.referenceFontFamilies[0] + ", " + adobeBlankFallbackFont;
      }
    },
    _getNewFontVariationsFromFonts: function(fontDescriptors) {
      var fontDescriptor, key, i,
          variations = [],
          variationsMap = {};

      for (i = 0; i < fontDescriptors.length; i++) {
        fontDescriptor = fontDescriptors[i];
        key = fontDescriptor.variationKey();
        if (!(key in variationsMap) && !(key in FontLoader.referenceFontFamilyVariationSizes)) {
          variationsMap[key] = true;
          variations.push({
            key: key,
            weight: fontDescriptor.weight,
            style: fontDescriptor.style,
            stretch: fontDescriptor.stretch
          });
        }
      }
      return variations;
    },
    _parseFonts: function(fonts) {
      var fontDescriptors = [], filteredFD,
          i, font, fontKey, fontKeys = {};

      for (i = 0; i < fonts.length; i++) {
        font = fonts[i];
        if (typeof font === "string") {
          if (font.indexOf(':') > -1) {
            fontDescriptors = fontDescriptors.concat(this._parseFVD(font));
          } else {
            fontDescriptors.push(new FontDescriptor({
              family: font,
              weight: 400,
              style: 'normal',
              stretch: 'normal'
            }));
          }
        } else {
          fontDescriptors.push(new FontDescriptor(font));
        }
      }

      // Filter duplicate fonts
      filteredFD = [];
      for (i = 0; i < fontDescriptors.length; i++) {
        fontKey = fontDescriptors[i].fontKey();
        if (!(fontKey in fontKeys)) {
          fontKeys[fontKey] = true;
          filteredFD.push(fontDescriptors[i]);
        }
      }

      return filteredFD;
    },
    /**
     * @param {string} fontString
     * @returns {Array.<FontDescriptor>}
     * @private
     */
    _parseFVD: function(fontString) {
      var fontDescriptors = [],
          parts = fontString.split(':'),
          fontFamily, variants, i, variant,
          styleAlias, weightAlias, stretchAlias,
          weight, style, stretch;

      fontFamily = parts[0];
      variants = parts[1].split(',');

      for (i = 0; i < variants.length; i++) {
        variant = variants[i];

        if (variant.length < 2 || variant.length > 3) {
          throw new Error("Invalid Font Variation Description: '" + fontString + "', number of variation characters must be 2 or 3");
        }

        styleAlias = variant[0];
        weightAlias = variant[1];
        stretchAlias = "n"; // stretch character is optional, default is 'n': 'normal'
        if (variant.length === 3) {
          stretchAlias = variant[2]
        }

        if (styleAlias in FontLoader.fontStyleAliasesMap) {
          style = FontLoader.fontStyleAliasesMap[styleAlias];
        } else {
          throw new Error("Invalid Font Variation Description: '" + fontString + "', the first variant character is not complying to FVD font-style specification");
        }

        weight = parseInt(weightAlias, 10);
        if (isNaN(weight)) {
          throw new Error("Invalid Font Variation Description: '" + fontString + "', the second variant character is not complying to FVD font-weight specification");
        } else {
          weight *= 100;
        }

        if (stretchAlias in FontLoader.fontStretchAliasesMap) {
          stretch = FontLoader.fontStretchAliasesMap[stretchAlias];
        } else {
          throw new Error("Invalid Font Variation Description: '" + fontString + "', the third variant character is not complying to FVD font-stretch specification");
        }

        fontDescriptors.push(new FontDescriptor({
          family: fontFamily,
          weight: weight,
          style: style,
          stretch: stretch
        }));
      }

      return fontDescriptors;
    },
    _addAdobeBlankFontFaceIfNeeded: function() {
      var adobeBlankFontFaceStyle;
      if (!this._document.getElementById(FontLoader.adobeBlankFontFaceStyleId)) {
        adobeBlankFontFaceStyle = this._document.createElement("style");
        adobeBlankFontFaceStyle.setAttribute("type", "text/css");
        adobeBlankFontFaceStyle.setAttribute("id", FontLoader.adobeBlankFontFaceStyleId);
        adobeBlankFontFaceStyle.appendChild(this._document.createTextNode(FontLoader.adobeBlankFontFaceRule));
        this._document.getElementsByTagName("head")[0].appendChild(adobeBlankFontFaceStyle);
      }
    },
    _checkAdobeBlankSize: function() {
      var adobeBlankDiv = this._testContainer.firstChild;
      this._adobeBlankLoaded(adobeBlankDiv);
    },
    _adobeBlankLoaded: function(adobeBlankDiv) {
      // Prevent false size change, for example if AdobeBlank height is higher than fallback font.
      if (adobeBlankDiv.offsetWidth !== 0) {
        return;
      }

      FontLoader.adobeBlankReferenceSize = new Size(adobeBlankDiv.offsetWidth, adobeBlankDiv.offsetHeight);

      if (this._adobeBlankSizeWatcher !== null) {
        // SizeWatcher method
        this._adobeBlankSizeWatcher.endWatching();
        this._adobeBlankSizeWatcher.removeScrollWatchers();
        this._adobeBlankSizeWatcher = null;
      } else {
        // Polling method (IE)
        window.clearInterval(this._intervalId);
        adobeBlankDiv.parentNode.removeChild(adobeBlankDiv);
      }

      this._testContainer.parentNode.removeChild(this._testContainer);

      this._loadFonts();
    },
    _cloneNodeSetStyleAndAttributes: function(font, fontKey, referenceFontFamilyIndex) {
      var clonedDiv = this._testDiv.cloneNode(true);
      clonedDiv.style.fontWeight = font.weight;
      clonedDiv.style.fontStyle = font.style;
      clonedDiv.style.fontStretch = font.stretch;
      clonedDiv.setAttribute("data-font-map-key", fontKey);
      clonedDiv.setAttribute("data-ref-font-family-index", String(referenceFontFamilyIndex));
      return clonedDiv;
    },
    _getFontMapKeyFromElement: function(element) {
      return element.getAttribute("data-font-map-key");
    },
    _getFontFromElement: function(element) {
      var fontKey = this._getFontMapKeyFromElement(element);
      return this._fontsMap[fontKey];
    },
    _getFontFamilyFromElement: function(element) {
      var font = this._getFontFromElement(element);
      return font.family;
    },
    _getReferenceFontFamilyIndexFromElement: function(element) {
      return element.getAttribute("data-ref-font-family-index");
    },
    _getReferenceFontFamilyFromElement: function(element) {
      var referenceFontFamilyIndex = this._getReferenceFontFamilyIndexFromElement(element);
      return FontLoader.referenceFontFamilies[referenceFontFamilyIndex];
    },
    _loadFonts: function() {
      var i, j, clonedDiv, sizeWatcher,
          font,
          fontKey,
          fontVariationKey,
          referenceFontSize,
          sizeWatcherDirection,
          sizeWatcherDimension,
          self = this;

      // Add div for each font-family
      for (i = 0; i < this._numberOfFonts; i++) {
        font = this._fontsArray[i];
        fontKey = font.fontKey();
        this._fontsMap[fontKey] = font;

        for (j = 0; j < FontLoader.referenceFontFamilies.length; j++) {
          clonedDiv = this._cloneNodeSetStyleAndAttributes(font, fontKey, j);
          if (FontLoader.useResizeEvent) {
            clonedDiv.style.fontFamily = FontLoader.referenceFontFamilies[j];
            this._testContainer.appendChild(clonedDiv);
          } else if (FontLoader.useIntervalChecking) {
            clonedDiv.style.fontFamily = "'" + font.family + "', " + FontLoader.referenceFontFamilies[j];
            this._testContainer.appendChild(clonedDiv);
          } else {
            clonedDiv.style.fontFamily = FontLoader.referenceFontFamilies[j];
            if (FontLoader.useAdobeBlank) {
              referenceFontSize = FontLoader.adobeBlankReferenceSize;
              sizeWatcherDirection = SizeWatcher.directions.increase;
              sizeWatcherDimension = SizeWatcher.dimensions.horizontal;
            } else {
              fontVariationKey = font.variationKey();
              referenceFontSize = FontLoader.referenceFontFamilyVariationSizes[fontVariationKey][j];
              sizeWatcherDirection = SizeWatcher.directions.both;
              sizeWatcherDimension = SizeWatcher.dimensions.both;
            }
            sizeWatcher = new SizeWatcher(/** @type HTMLElement */clonedDiv, {
              container: this._testContainer,
              delegate: this,
              size: referenceFontSize,
              direction: sizeWatcherDirection,
              dimension: sizeWatcherDimension,
              document: this._document
            });
            // The prepareForWatch() and beginWatching() methods will be invoked in separate iterations to
            // reduce number of browser's CSS recalculations.
            this._sizeWatchers.push(sizeWatcher);
          }
        }
      }

      // Append the testContainer after all test elements to minimize DOM insertions
      this._document.body.appendChild(this._testContainer);

      if (FontLoader.useResizeEvent) {
        for (j = 0; j < this._testContainer.childNodes.length; j++) {
          clonedDiv = this._testContainer.childNodes[j];
          // "resize" event works only with attachEvent
          clonedDiv.attachEvent("onresize", (function(self, clonedDiv) {
            return function() {
              self._elementSizeChanged(clonedDiv);
            }
          })(this, clonedDiv));
        }
        window.setTimeout(function() {
          for (j = 0; j < self._testContainer.childNodes.length; j++) {
            clonedDiv = self._testContainer.childNodes[j];
            clonedDiv.style.fontFamily = "'" + self._getFontFamilyFromElement(clonedDiv) + "', " + self._getReferenceFontFamilyFromElement(clonedDiv);
          }
        }, 0);
      } else if (FontLoader.useIntervalChecking) {
        // Start polling element sizes but also do first synchronous check in case all fonts where already loaded.
        this._intervalId = window.setInterval(function intervalFire() {
          self._checkSizes();
        }, this._intervalDelay);
        this._checkSizes();
      } else {
        // We are dividing the prepareForWatch() and beginWatching() methods to optimize browser performance by
        // removing CSS recalculation from each iteration to the end of iterations.
        for (i = 0; i < this._sizeWatchers.length; i++) {
          sizeWatcher = this._sizeWatchers[i];
          sizeWatcher.prepareForWatch();
        }
        for (i = 0; i < this._sizeWatchers.length; i++) {
          sizeWatcher = this._sizeWatchers[i];
          sizeWatcher.beginWatching();
          // Apply tested font-family
          clonedDiv = sizeWatcher.getWatchedElement();
          clonedDiv.style.fontFamily = "'" + this._getFontFamilyFromElement(clonedDiv) + "', " + self._getReferenceFontFamilyFromElement(clonedDiv);
        }
      }
    },
    _checkSizes: function() {
      var i, testDiv, font, fontVariationKey, currSize, refSize, refFontFamilyIndex;

      for (i = this._testContainer.childNodes.length - 1; i >= 0; i--) {
        testDiv = this._testContainer.childNodes[i];
        currSize = new Size(testDiv.offsetWidth, testDiv.offsetHeight);
        if (FontLoader.useAdobeBlank) {
          refSize = FontLoader.adobeBlankReferenceSize;
        } else {
          font = this._getFontFromElement(testDiv);
          fontVariationKey = font.variationKey();
          refFontFamilyIndex = this._getReferenceFontFamilyIndexFromElement(testDiv);
          refSize = FontLoader.referenceFontFamilyVariationSizes[fontVariationKey][refFontFamilyIndex];
        }
        if (!refSize.isEqual(currSize)) {
          // Element dimensions changed, this means its font loaded, remove it from testContainer div
          testDiv.parentNode.removeChild(testDiv);
          this._elementSizeChanged(testDiv);
        }
      }
    },
    _elementSizeChanged: function(element) {
      var font, fontKey;

      if (this._finished) {
        return;
      }

      fontKey = this._getFontMapKeyFromElement(element);

      // Check that the font of this element wasn't already marked as loaded by an element with different reference font family.
      if (typeof this._fontsMap[fontKey] === "undefined") {
        return;
      }

      font = this._fontsMap[fontKey];

      this._numberOfLoadedFonts++;
      delete this._fontsMap[fontKey];

      if (this.delegate && typeof this.delegate.fontLoaded === "function") {
        this.delegate.fontLoaded(font.toJSON());
      }

      if (this._numberOfLoadedFonts === this._numberOfFonts) {
        this._finish();
      }
    },
    _finish: function() {
      var error, i, sizeWatcher,
          fontKey,
          notLoadedFonts = [];

      if (this._finished) {
        return;
      }

      this._finished = true;

      if (this._adobeBlankSizeWatcher !== null) {
        if (this._adobeBlankSizeWatcher.getState() === SizeWatcher.states.watchingForSizeChange) {
          this._adobeBlankSizeWatcher.endWatching();
        }
        this._adobeBlankSizeWatcher = null;
      }

      for (i = 0; i < this._sizeWatchers.length; i++) {
        sizeWatcher = this._sizeWatchers[i];
        if (sizeWatcher.getState() === SizeWatcher.states.watchingForSizeChange) {
          sizeWatcher.endWatching();
        }
      }
      this._sizeWatchers = [];

      if (this._testContainer !== null) {
        this._testContainer.parentNode.removeChild(this._testContainer);
      }

      if (this._timeoutId !== null) {
        window.clearTimeout(this._timeoutId);
      }

      if (this._intervalId !== null) {
        window.clearInterval(this._intervalId);
      }

      if (this.delegate) {
        if (this._numberOfLoadedFonts < this._numberOfFonts) {
          for (fontKey in this._fontsMap) {
            if (this._fontsMap.hasOwnProperty(fontKey)) {
              notLoadedFonts.push(this._fontsMap[fontKey].toJSON());
            }
          }
          error = {
            message: "Not all fonts were loaded (" + this._numberOfLoadedFonts + "/" + this._numberOfFonts + ")",
            notLoadedFonts: notLoadedFonts
          };
        } else {
          error = null;
        }
        if (typeof this.delegate.complete === "function") {
          this.delegate.complete(error);
        } else if (typeof this.delegate.fontsLoaded === "function") {
          this.delegate.fontsLoaded(error);
        }
      }
    },
    /**
     * SizeWatcher delegate method
     * @param {SizeWatcher} sizeWatcher
     */
    sizeWatcherChangedSize: function(sizeWatcher) {
      var watchedElement = sizeWatcher.getWatchedElement();
      if (sizeWatcher === this._adobeBlankSizeWatcher) {
        this._adobeBlankLoaded(watchedElement);
      } else {
        this._elementSizeChanged(watchedElement);
      }
    }
  };

  /**
   * Size object
   *
   * @param width
   * @param height
   * @constructor
   */
  function Size(width, height) {
    this.width = width;
    this.height = height;
  }

  Size.sizeFromString = function(sizeString) {
    var arr = sizeString.split(",");
    if (arr.length !== 2) {
      return null;
    }
    return new Size(arr[0], arr[1]);
  };

  /**
   * Compares receiver object to passed in size object.
   *
   * @param otherSize
   * @returns {boolean}
   */
  Size.prototype.isEqual = function(otherSize) {
    return (this.width === otherSize.width && this.height === otherSize.height);
  };

  Size.prototype.toString = function() {
    return this.width + "," + this.height;
  };

  /**
   * SizeWatcher observes size of an element and notifies when its size is changed. It doesn't use any timeouts
   * to check the element size, when change in size occurs a callback method immediately invoked.
   *
   * To watch for element's size changes the element, and other required elements are appended to a container element
   * you specify, and which must be added to the DOM tree before invoking prepareForWatch() method. Your container
   * element should be positioned outside of client's visible area. Therefore you shouldn't use SizeWatcher to watch
   * for size changes of elements used for UI.
   * Such container element could be a simple <div> that is a child of the <body> element:
   * <div style="position:absolute; left:-10000px; top:-10000px;"></div>
   *
   * You must invoke SizeWatcher's methods in a specific order to establish size change listeners:
   *
   * 1. Create SizeWatcher instance by invoke SizeWatcher constructor passing the element (size of which you want to
   *    observe), the container element, the delegate object and optional size parameter of type Size which should be
   *    the pre-calculated initial size of your element.
   * 4. Invoke prepareForWatch() method. This method will calculate element size if you didn't passed it to the constructor.
   * 5. Invoke beginWatching() method. This method will set event listeners and invoke your delegate's method once
   *    element size changes.
   *
   * Failing to invoke above methods in their predefined order will throw an exception.
   *
   * @param {HTMLElement}   element An element, size of which will be observed for changes.
   * @param {Object}        options
   * @param {HTMLElement}   options.container An element to which special observing elements will be added. Must be in DOM tree
   *                        when prepareForWatch() method is called.
   * @param {Object}        options.delegate A delegate object with a sizeWatcherChangedSize method which will be invoked, in
   *                        context of the delegate object, when change in size occurs. This method is invoked with single
   *                        parameter which is the current SizeWatcher instance.
   * @param {Size}          [options.size] The pre-calculated initial size of your element. When passed, the element is not
   *                        asked for offsetWidth and offsetHeight, which may be useful to reduce browser's CSS
   *                        recalculations. If you will not pass the size parameter then its size calculation will be
   *                        deferred to prepareForWatch() method.
   * @param {Boolean}       [options.continuous=false] A boolean flag indicating if the SizeWatcher will watch only for
   *                        the first size change (default) or will continuously watch for size changes.
   * @param {Number}        [options.direction=SizeWatcher.directions.both] The direction of size change that should be
   *                        watched: SizeWatcher.directions.increase, SizeWatcher.directions.decrease or
   *                        SizeWatcher.directions.both
   * @param {Number}        [options.dimension=SizeWatcher.dimensions.both] The dimension of size change that should be
   *                        watched: SizeWatcher.dimensions.horizontal, SizeWatcher.dimensions.vertical or
   *                        SizeWatcher.dimensions.both
   * @param {HTMLDocument}  [options.document] The DOM tree context to use, if none provided then it will be the document.
   * @constructor
   */
  function SizeWatcher(element, options) {
    this._element = element;
    this._delegate = options.delegate;
    this._size = null;
    this._continuous = !!options.continuous;
    this._direction = options.direction ? options.direction : SizeWatcher.directions.both;
    this._dimension = options.dimension ? options.dimension : SizeWatcher.dimensions.both;
    this._sizeIncreaseWatcherContentElm = null;
    this._sizeDecreaseWatcherElm = null;
    this._sizeIncreaseWatcherElm = null;
    this._state = SizeWatcher.states.initialized;
    this._scrollAmount = 2;
    this._document = options.document || document;

    this._generateScrollWatchers(options.size);
    this._appendScrollWatchersToElement(options.container);
  }

  SizeWatcher.states = {
    initialized: 0,
    generatedScrollWatchers: 1,
    appendedScrollWatchers: 2,
    preparedScrollWatchers: 3,
    watchingForSizeChange: 4
  };

  SizeWatcher.directions = {
    decrease: 1,
    increase: 2,
    both: 3
  };

  SizeWatcher.dimensions = {
    horizontal: 1,
    vertical: 2,
    both: 3
  };

  //noinspection JSUnusedLocalSymbols
  SizeWatcher.prototype = {
    constructor: SizeWatcher,
    getWatchedElement: function() {
      return this._element;
    },
    getState: function() {
      return this._state;
    },
    setSize: function(size) {
      this._size = size;
      //noinspection JSBitwiseOperatorUsage
      if (this._direction & SizeWatcher.directions.increase) {
        this._sizeIncreaseWatcherContentElm.style.cssText = "width: " + (size.width + this._scrollAmount) + "px; height: " + (size.height + this._scrollAmount) + "px;";
      }
      //noinspection JSBitwiseOperatorUsage
      if (this._direction & SizeWatcher.directions.decrease) {
        this._sizeDecreaseWatcherElm.style.cssText = "position:absolute; left: 0px; top: 0px; overflow: hidden; width: " + (size.width - this._scrollAmount) + "px; height: " + (size.height - this._scrollAmount) + "px;";
      }
    },
    _generateScrollWatchers: function(size) {

      this._element.style.position = "absolute";

      //noinspection JSBitwiseOperatorUsage
      if (this._direction & SizeWatcher.directions.increase) {
        this._sizeIncreaseWatcherContentElm = this._document.createElement("div");

        this._sizeIncreaseWatcherElm = this._document.createElement("div");
        this._sizeIncreaseWatcherElm.style.cssText = "position: absolute; left: 0; top: 0; width: 100%; height: 100%; overflow: hidden;";
        this._sizeIncreaseWatcherElm.appendChild(this._sizeIncreaseWatcherContentElm);

        this._element.appendChild(this._sizeIncreaseWatcherElm);
      }

      //noinspection JSBitwiseOperatorUsage
      if (this._direction & SizeWatcher.directions.decrease) {
        this._sizeDecreaseWatcherElm = this._document.createElement("div");
        this._sizeDecreaseWatcherElm.appendChild(this._element);
      }

      if (size) {
        this.setSize(size);
      }

      this._state = SizeWatcher.states.generatedScrollWatchers;
    },
    _appendScrollWatchersToElement: function(container) {
      if (this._state !== SizeWatcher.states.generatedScrollWatchers) {
        throw new Error("SizeWatcher._appendScrollWatchersToElement() was invoked before SizeWatcher._generateScrollWatchers()");
      }

      //noinspection JSBitwiseOperatorUsage
      if (this._direction & SizeWatcher.directions.decrease) {
        container.appendChild(this._sizeDecreaseWatcherElm);
      } else {
        container.appendChild(this._element);
      }

      this._state = SizeWatcher.states.appendedScrollWatchers;
    },
    removeScrollWatchers: function() {
      //noinspection JSBitwiseOperatorUsage
      if (this._direction & SizeWatcher.directions.decrease) {
        if (this._sizeDecreaseWatcherElm.parentNode) {
          this._sizeDecreaseWatcherElm.parentNode.removeChild(this._sizeDecreaseWatcherElm);
        }
      } else if (this._element.parentNode) {
        this._element.parentNode.removeChild(this._element);
      }
    },
    prepareForWatch: function() {
      var parentNode,
          sizeDecreaseWatcherElmScrolled = true,
          sizeIncreaseWatcherElmScrolled = true;

      if (this._state !== SizeWatcher.states.appendedScrollWatchers) {
        throw new Error("SizeWatcher.prepareForWatch() invoked before SizeWatcher._appendScrollWatchersToElement()");
      }

      if (this._size === null) {
        this.setSize(new Size(this._element.offsetWidth, this._element.offsetHeight));
      }

      //noinspection JSBitwiseOperatorUsage
      if (this._direction & SizeWatcher.directions.decrease) {
        sizeDecreaseWatcherElmScrolled = this._scrollElementToBottomRight(this._sizeDecreaseWatcherElm);
      }
      //noinspection JSBitwiseOperatorUsage
      if (this._direction & SizeWatcher.directions.increase) {
        sizeIncreaseWatcherElmScrolled = this._scrollElementToBottomRight(this._sizeIncreaseWatcherElm);
      }

      // Check if scroll positions updated.
      if (!sizeDecreaseWatcherElmScrolled || !sizeIncreaseWatcherElmScrolled) {

        // Traverse tree to the top node to see if element is in the DOM tree.
        parentNode = this._element.parentNode;
        while (parentNode !== this._document && parentNode !== null) {
          parentNode = parentNode.parentNode;
        }

        if (parentNode === null) {
          throw new Error("Can't set scroll position of scroll watchers. SizeWatcher is not in the DOM tree.");
        } else if (console && typeof console.warn === "function") {
          console.warn("SizeWatcher can't set scroll position of scroll watchers.");
        }
      }

      this._state = SizeWatcher.states.preparedScrollWatchers;
    },
    _scrollElementToBottomRight: function(element) {
      var elementScrolled = true;
      //noinspection JSBitwiseOperatorUsage
      if (this._dimension & SizeWatcher.dimensions.vertical) {
        element.scrollTop = this._scrollAmount;
        elementScrolled = elementScrolled && element.scrollTop > 0;
      }
      //noinspection JSBitwiseOperatorUsage
      if (this._dimension & SizeWatcher.dimensions.horizontal) {
        element.scrollLeft = this._scrollAmount;
        elementScrolled = elementScrolled && element.scrollLeft > 0;
      }
      return elementScrolled;
    },
    beginWatching: function() {
      if (this._state !== SizeWatcher.states.preparedScrollWatchers) {
        throw new Error("SizeWatcher.beginWatching() invoked before SizeWatcher.prepareForWatch()");
      }

      //noinspection JSBitwiseOperatorUsage
      if (this._direction & SizeWatcher.directions.decrease) {
        //noinspection JSValidateTypes
        this._sizeDecreaseWatcherElm.addEventListener("scroll", this, false);
      }
      //noinspection JSBitwiseOperatorUsage
      if (this._direction & SizeWatcher.directions.increase) {
        //noinspection JSValidateTypes
        this._sizeIncreaseWatcherElm.addEventListener("scroll", this, false);
      }

      this._state = SizeWatcher.states.watchingForSizeChange;
    },
    endWatching: function() {
      if (this._state !== SizeWatcher.states.watchingForSizeChange) {
        throw new Error("SizeWatcher.endWatching() invoked before SizeWatcher.beginWatching()");
      }

      //noinspection JSBitwiseOperatorUsage
      if (this._direction & SizeWatcher.directions.decrease) {
        //noinspection JSValidateTypes
        this._sizeDecreaseWatcherElm.removeEventListener("scroll", this, false);
      }
      //noinspection JSBitwiseOperatorUsage
      if (this._direction & SizeWatcher.directions.increase) {
        //noinspection JSValidateTypes
        this._sizeIncreaseWatcherElm.removeEventListener("scroll", this, false);
      }
      this._state = SizeWatcher.states.appendedScrollWatchers;
    },
    /**
     * @private
     */
    handleEvent: function(event) {
      var newSize, oldSize;

      // This is not suppose to happen because when we run endWatching() we remove scroll listeners.
      // But some browsers will fire second scroll event which was pushed into event stack before listener was
      // removed so do this check anyway.
      if (this._state !== SizeWatcher.states.watchingForSizeChange) {
        return;
      }

      newSize = new Size(this._element.offsetWidth, this._element.offsetHeight);
      oldSize = this._size;

      // Check if element size is changed. How come that element size isn't changed but scroll event fired?
      // This can happen in two cases: when double scroll occurs or immediately after calling prepareForWatch()
      // (event if scroll event listeners attached after it).
      // The double scroll event happens when one size dimension (e.g.:width) is increased and another
      // (e.g.:height) is decreased.
      if (oldSize.isEqual(newSize)) {
        return;
      }

      if (this._delegate && typeof this._delegate.sizeWatcherChangedSize === "function") {
        this._delegate.sizeWatcherChangedSize(this);

        // Check that endWatching() wasn't invoked from within the delegate.
        if (this._state !== SizeWatcher.states.watchingForSizeChange) {
          return;
        }
      }

      if (!this._continuous) {
        this.endWatching();
      } else {
        // Set the new size so in case of double scroll event we won't cause the delegate method to be executed twice
        // and also to update to the new watched size.
        this.setSize(newSize);
        // change state so prepareFowWatch() won't throw exception about wrong order invocation.
        this._state = SizeWatcher.states.appendedScrollWatchers;
        // Run prepareForWatch to reset the scroll watchers, we have already set the size
        this.prepareForWatch();
        // Set state to listeningForSizeChange, there is no need to invoke beginWatching() method as scroll event
        // listeners and callback are already set.
        this._state = SizeWatcher.states.watchingForSizeChange;

      }
    }
  };

  return FontLoader;

}));
function waitForWebfonts(fonts, callback) {
  if (fonts.length === 0) {
	callback();
	return;
  }
  var maxTime = 10 * 1000;
  var startTime = new Date().getTime();
  var loadedFonts = 0;
  var callbackIsRun = false;
  for(var i = 0, l = fonts.length; i < l; ++i) {
	(function(font) {
	  var container = document.createElement('div');
	  container.style.position = 'absolute';
	  container.style.width = 0;
	  document.body.appendChild(container);
	  var node = document.createElement('span');
	  // Characters that vary significantly among different fonts
	  if (font === 'FontAwesome') {
		node.innerHTML = '<i class="fa-facebook-square"></i>';
	  }
	  else {
		node.innerHTML = 'giItT1WQy@!-/#';
	  }
	  // Visible - so we can measure it - but not on the screen
	  node.style.position      = 'absolute';
	  node.style.left          = '-10000px';
	  node.style.top           = '-10000px';
	  // Large font size makes even subtle changes obvious
	  node.style.fontSize      = '300px';
	  // Reset any font properties
	  node.style.fontVariant   = 'normal';
	  node.style.fontStyle     = 'normal';
	  node.style.fontWeight    = 'normal';
	  node.style.letterSpacing = '0';
	  container.appendChild(node);

	  // Remember width with no applied web font
	  var width = node.offsetWidth;
	  if (font === 'FontAwesome') {
		node.innerHTML = '<i class="fa fa-facebook-square"></i>';
	  }
	  else {
		node.style.fontFamily = font;
	  }

	  var interval;
	  function checkFont () {
		// Compare current width with original width
		if (node && (new Date().getTime() - startTime > maxTime || node.offsetWidth != width)) {
		  ++loadedFonts;
		  node.parentNode.removeChild(node);
		  node = null;
		  if (interval) {
			clearInterval(interval);
		  }
		}

		// If all fonts have been loaded
		if(loadedFonts >= fonts.length) {
		  if(loadedFonts == fonts.length) {
			if (!callbackIsRun) {
			  callback();
			}
			callbackIsRun = true;
			return true;
		  }
		}
	  };

	  setTimeout(function () {
		if(!checkFont()) {
		  interval = setInterval(checkFont, 50);
		}
	  });
	})(fonts[i]);
  }
};
(function () {
  var uncurryConfig = function (f, valueIsNotConfig) {
	valueIsNotConfig = valueIsNotConfig || function (obj) {
	  return $.type(obj) === 'array' || $.type(obj) === 'function';
	};
	return function () {
	  var args = Array.prototype.slice.call(arguments);
	  var firstArgIsConfig = !valueIsNotConfig(args[0]);
	  if ((args.length - (firstArgIsConfig ? 1 : 0)) > 0) {
		var args0 = [];
		if (firstArgIsConfig) {
		  args0 = args.splice(0, 1);
		}
		return f.apply(null, args0).apply(null, args);
	  }
	  var arg = args[0];
	  return function () {
		var args = Array.prototype.slice.call(arguments);
		return f.apply(null, [arg]).apply(null, args);
	  };
	};
  };
  var lrmIsNotConfig = function (obj) {
	return obj.l || obj.r || obj.m;
  };
  var tbmIsNotConfig = function (obj) {
	return obj.t || obj.b || obj.m;
  };
  var caseSplit = function (cases, obj) {
	// may curry
	if (!obj) {
	  return function (obj) {
		for (var key in cases) {
		  if (cases.hasOwnProperty(key) && obj.hasOwnProperty(key)) {
			if (!$.isFunction(cases[key])) {
			  return cases[key];
			}
			return cases[key](obj[key]);
		  }
		}
	  };
	}
	for (var key in cases) {
	  if (cases.hasOwnProperty(key) && obj.hasOwnProperty(key)) {
		if (!$.isFunction(cases[key])) {
		  return cases[key];
		}
		return cases[key](obj[key]);
	  }
	}
  };
  var apply = function (v) {
	return function (f) {
	  return f(v);
	};
  };
  var constant = function (b) {
	return function (a) {
	  return b;
	};
  };
  var curry = function (arr) {
	throw('the venerable curry, we shall define at a later date');
  };
  var uncurry = function (f, n) {
	n = n || 1;
	return function () {
	  var args = Array.prototype.slice.call(arguments);
	  var arg0 = [null];
	  if (args.length > n) {
		arg0 = args.splice(0, 1);
	  }
	  return f.apply(null, arg0).apply(null, args);
	};
  };
  var id = function (a) {
	return a;
  };
  var add = function (a, b) {
	return a + b;
  };
  var subtract = function (a, b) {
	return a - b;
  };
  var mathMax = function (a, b) {
	return Math.max(a, b);
  };
  var mathMin = function (a, b) {
	return Math.min(a, b);
  };

  var pushStreams = [];
  var pushValues = [];
  var pushing = false;
  var pushFlush = function () {
	var ps = pushStreams;
	var pv = pushValues;
	pushStreams = [];
	pushValues = [];
	pushing = false;
	for (var j = 0; j < ps.length; j++) {
	  var s = ps[j];
	  var v = pv[j];
	}
  };
  var pushNow = function (s, v) {
	pushStreams.push(s);
	pushValues.push(v);
	if (pushing === false) {
	  pushing = true;
	  setTimeout(function () {
		setTimeout(pushFlush);
	  });
	}
  };

  var createDeferFuncContext = function (runASAP) {
	/*
	 WARNING:

	 This is a hacky implementation of something that already exists.
	 Do not use this little function.  When I find out what it is that
	 this function crudely implements, I will find and use an existing
	 library for it.

	 */
	runASAP = runASAP || setTimeout;
	var nextFuncs = [];
	var running = false;
	var deferFunc = function (f) {
	  runASAP(function () {
		if (nextFuncs.length === 0) {
		  f();
		}
		else {
		  deferFunc(f);
		}
	  });
	};
	var childContext = null;
	var deferFuncContext = {
	  next: function (f) {
		nextFuncs.push(f);
		if (running === false) {
		  running = true;
		  runASAP(function () {
			running = false;
			var runFuncs = nextFuncs;
			nextFuncs = [];
			runFuncs.map(function (f) {
			  f();
			});
		  });
		}
		return deferFuncContext;
	  },
	  childContext: function () {
		childContext = childContext || createDeferFuncContext(deferFunc);
		return childContext;
	  },
	  defer: function (f) {
		var childContext = deferFuncContext.childContext();
		childContext.next(f);
		return childContext;
	  },
	};
	return deferFuncContext;
  };

  var streamDeferFunc = createDeferFuncContext();
  var stream = {
	create: function (v) {
	  return {
		listeners: [],
		lastValue: v,
	  };
	},
	next: streamDeferFunc.next,
	defer: streamDeferFunc.childContext().defer,
	isStream: function (v) {
	  return v &&
		v.hasOwnProperty('listeners') &&
		v.hasOwnProperty('lastValue');
	},
	once: function (v) {
	  return stream.create(v);
	},
	push: function (s, v) {
	  if (Number.isNaN(v)) {
		debugger;
	  }
	  streamDeferFunc.next(function () {
		if (s.lastValue !== v) {
		  s.lastValue = v;
		  if (Number.isNaN(v)) {
			debugger;
		  }
		  for (var i = 0; i < s.listeners.length; i++) {
			if (s.listeners[i]) {
			  s.listeners[i](v);
			}
		  }
		}
	  });
	},
	map: function (s, f) {
	  var out = stream.create();
	  if (s.lastValue !== undefined) {
		stream.push(out, f(s.lastValue));
	  }
	  s.listeners.push(function (v) {
		stream.push(out, f(v));
	  });
	  return out;
	},
	reduce: function (s, f, v1) {
	  var out = stream.once(v1);
	  if (s.lastValue !== undefined) {
		stream.push(out, f(out.lastValue, s.lastValue));
	  }
	  stream.map(s, function (v) {
		stream.push(out, f(out.lastValue, v));
	  });
	  return out;
	},
	filter: function (s, f) {
	  var out = stream.create();
	  s.listeners.push(function (v) {
		if (f(v)) {
		  stream.push(out, v);
		}
	  });
	  return stream;
	},
	onValue: function (s, f) {
	  stream.map(s, function (v) {
		f(v);
		return true;
	  });
	  var index = s.listeners.length - 1;
	  return function () {
		delete s.listeners[index];
	  };
	},
	promise: function (s) {
	  var d = $.Deferred();
	  stream.map(s, function (v) {
		d.resolve(v);
	  });
	  return d.promise;
	},
	prop: function (s, str) {
	  return stream.map(s, function (v) {
		return v[str];
	  });
	},
	delay: function (s, amount) {
	  var out = stream.create();
	  stream.map(s, function (v) {
		setTimeout(function () {
		  stream.push(out, v);
		}, amount);
	  });
	  return out;
	},
	debounce: function (s, amount) {
	  var out = stream.create();
	  var lastPushed = 0;
	  var running = false;
	  stream.map(s, function (v) {
		if (!running) {
		  running = true;
		  var d = new Date().getTime();
		  setTimeout(function () {
			running = false;
			stream.push(out, s.lastValue);
			lastPushed = Math.max(lastPushed + amount, d);
		  }, Math.max(0, (lastPushed + amount) - d));
		}
	  });
	  return out;
	},
	pushAll: function (source, target) {
	  if (source.lastValue !== undefined) {
		stream.push(target, source.lastValue);
	  }
	  return stream.onValue(source, function (v) {
		stream.push(target, v);
	  });
	},
	clone: function (s) {
	  var out = stream.create();
	  stream.pushAll(s, out);
	  return out;
	},
	combine: function (streams, f) {
	  var arr = [];
	  var out = stream.create();

	  var running = false;
	  var tryRunF = function () {
		if (!running) {
		  running = true;
		  streamDeferFunc.defer(function () {
			running = false;
			for (var i = 0; i < streams.length; i++) {
			  if (arr[i] === undefined) {
				return;
			  }
			}
			stream.push(out, f.apply(null, arr));
		  });
		}
	  };

	  streams.reduce(function (i, s) {
		if (s.lastValue !== undefined) {
		  arr[i] = s.lastValue;
		  tryRunF();
		}
		stream.onValue(s, function (v) {
		  arr[i] = v;
		  tryRunF();
		});
		return i + 1;
	  }, 0);

	  return out;
	},
	combineInto: function (streams, f, out) {
	  var arr = [];

	  var running = false;
	  var tryRunF = function () {
		if (!running) {
		  running = true;
		  streamDeferFunc.defer(function () {
			running = false;
			for (var i = 0; i < streams.length; i++) {
			  if (arr[i] === undefined) {
				return;
			  }
			}
			stream.push(out, f.apply(null, arr));
		  });
		}
	  };

	  streams.reduce(function (i, s) {
		if (s.lastValue !== undefined) {
		  arr[i] = s.lastValue;
		  tryRunF();
		}
		stream.onValue(s, function (v) {
		  arr[i] = v;
		  tryRunF();
		});
		return i + 1;
	  }, 0);
	},
	all: function (streams, f) {
	  return stream.combine(streams, function () {
		return Array.prototype.slice.call(arguments);
	  });
	},
	combineObject: function (streamsObject) {
	  var keys = Object.keys(streamsObject);
	  var obj = {};
	  var out = stream.create();

	  var running = false;
	  var tryRunF = function () {
		if (!running) {
		  running = true;
		  setTimeout(function () {
			running = false;
			for (var i = 0; i < keys.length; i++) {
			  var key = keys[i];
			  if (obj[key] === undefined) {
				return;
			  }
			}
			stream.push(out, $.extend({}, obj));
		  });
		}
	  };

	  keys.map(function (key, i) {
		stream.onValue(streamsObject[key], function (v) {
		  obj[key] = v;
		  tryRunF();
		});
	  });

	  return out;
	},
	splitObject: function (obj) {
	  var keys = Object.keys(obj);
	  var streams = {};
	  keys.map(function (key) {
		streams[key] = stream.once(obj[key]);
	  });
	  return streams;
	},
	fromEvent: function ($el, event) {
	  var s = stream.create();
	  $el.on('event', function (ev) {
		stream.push(s, ev);
	  });
	  return s;
	},
	fromPromise: function (p, initialValue) {
	  var out = stream.create();
	  if (initialValue) {
		stream.push(out, initialValue);
	  }
	  p.then(function (v) {
		stream.push(out, v);
	  });
	  return out;
	},
	cases: function (streams, indexS) {
	  streams.push(indexS);
	  return stream.combine(streams, function () {
		var args = Array.prototype.slice.call(arguments);
		var index = args.pop();
		return args[index];
	  });
	},
  };


  var unit = function (unit) {
	return function (number) {
	  return number + unit;
	};
  };
  var px = unit('px');
  var vw = unit('vw');

  var onceZeroS = stream.once(0);


  var windowWidth = stream.create();
  stream.windowWidth = windowWidth;
  var windowHeight = stream.create();
  stream.windowHeight = windowHeight;
  var updateWindowWidth = function () {
	stream.push(windowWidth, window.innerWidth);
  };
  var updateWindowHeight = function () {
	stream.push(windowHeight, window.innerHeight);
  };
  $(updateWindowWidth);
  $(updateWindowHeight);
  $(window).on('resize', function () {
	updateWindowWidth();
	updateWindowHeight();
  });
  var windowResize = stream.once(null, true);
  $(window).on('resize', function (e) {
	stream.push(windowResize, e);
  });

  var windowScroll = stream.create(true);
  $(window).on('scroll', function () {
	stream.push(windowScroll, window.scrollY);
  });
  stream.push(windowScroll, window.scrollY);

  var windowHash = stream.create(true);
  $(window).on('hashchange', function () {
	stream.push(windowHash, location.pathname);
  });
  stream.push(windowHash, location.pathname);

  // this stream assumes only one rootComponent per web page!
  var displayedS = stream.once(false);

  var updateDomEls = [];
  var updateDomProps = [];
  var updateDomValues = [];
  var runDomFuncs = function () {
	for (var i = 0; i < updateDomEls.length; i++) {
	  updateDomEls[i].css(updateDomProps[i], updateDomValues[i]);
	}
	updateDomEls = [];
	updateDomProps = [];
	updateDomValues = [];
  };
  var updateDomFunc = function ($el, ctx, prop, value) {
	if (updateDomEls.length === 0) {
	  stream.defer(runDomFuncs);
	}
	updateDomEls.push($el);
	updateDomProps.push(prop);
	updateDomValues.push(value);
  };

  var canvas = document.createElement('canvas');
  var $canvas = $(canvas);
  var ctx = canvas.getContext('2d');

  var decodeDiv = document.createElement('div');
  var htmlDecode = function (input) {
	decodeDiv.innerHTML = input;
	return decodeDiv.childNodes.length === 0 ? "" : decodeDiv.childNodes[0].nodeValue;
  };

  var measureTextWidth = function (str, font) {
	if (font) {
	  ctx.font = font;
	}
	return ctx.measureText(str).width;
  };
  var measureTextHeight = function (strs, lineHeight) {
	var ws = {};
	var strsOriginal = strs;
	strsOriginal.map(function (str) {
	  str.originalWords = str.words;
	});
	return function (w) {
	  strs = strsOriginal.slice(0);
	  // if (ws[w]) {
	  // 	return ws[w];
	  // }

	  var outputLines = 0;
	  var thisLineLength = 0;
	  var thisLineHeight = 0;
	  if (strs.length === 0) {
		return 0;
	  }
	  var str = strs[0];
	  ctx.font = str.font;
	  str.words = str.originalWords.slice(0);
	  while (strs.length > 0) {
		var word = str.words[0] + ((strs.length > 1 || str.words.length > 1) ? ' ' : '');
		var wordWidth = measureTextWidth(word);
		if (wordWidth + thisLineLength > w) {
		  outputLines += thisLineHeight;
		  thisLineLength = 0;
		  thisLineHeight = 0;
		}
		thisLineLength += wordWidth;
		thisLineHeight = Math.max(thisLineHeight, parseInt(str.size)); // assumes px
		str.words.splice(0, 1);
		if (str.words.length === 0) {
		  strs.splice(0, 1);
		  if (strs.length > 0) {
			str = strs[0];
			str.words = str.words.slice(0);
			ctx.font = str.font;
		  }
		}
	  }

	  var height = (outputLines + thisLineHeight) * (lineHeight || 1);

	  ws[w] = height;
	  return height;
	};
  };

  var measureWidth = function ($el, w) {
	var $sandbox = $('.sandbox');
	var $clone = $el.clone();
	$clone.css('width', w ? px(w) : '')
	  .css('height', '')
	  .css('display', 'inline-block')
	  .appendTo($sandbox);

	var width = parseFloat($clone.css('width'));
	$clone.remove();

	return width;
  };

  var measureHeight = function ($el) {
	var ws = {};
	return function (w) {
	  if (ws[w]) {
		return ws[w];
	  }
	  var $sandbox = $('.sandbox');
	  var $clone = $el.clone();
	  $clone.css('width', px(w))
		.css('height', '')
		.appendTo($sandbox);

	  var height = parseFloat($clone.css('height'));
	  ws[w] = height;

	  $clone.remove();

	  return height;
	};
  };

  var componentFunc = function (name, build, context) {
	var $el = $(document.createElement(name));

	$el.css('pointer-events', 'initial');

	var onRemove = [];
	context.append = function (c, ctx) {
	  if (!instance) {
		instance = ctx;
	  }
	  ctx = ctx || {};
	  try {
		ctx.$el = ctx.$el || $el;
		ctx.width = ctx.width || context.width;
		ctx.height = ctx.height || context.height;
		ctx.top = ctx.top || onceZeroS;
		ctx.left = ctx.left || onceZeroS;
		ctx.topOffset = stream.combine([context.topOffset, context.top], add);
		ctx.leftOffset = stream.combine([context.leftOffset, context.left], add);
		ctx.onRemove = onRemove.push;
		stream = stream;
		return c(ctx);
	  }
	  catch (e) {
		debugger;
	  }
	};

	$el.css('visibility', 'hidden')
	  .css('pointer-events', 'initial')
	  .css('position', 'absolute');
	stream.onValue(context.widthCss || context.width, function (w) {
	  updateDomFunc($el, context, 'width', w);
	});
	stream.onValue(context.heightCss || context.height, function (h) {
	  updateDomFunc($el, context, 'height', h);
	});
	stream.onValue(context.topCss || context.top, function (t) {
	  updateDomFunc($el, context, 'top', t);
	});
	stream.onValue(context.leftCss || context.left, function (l) {
	  updateDomFunc($el, context, 'left', l);
	});
	stream.combine([
	  context.width,
	  context.height,
	  context.top,
	  context.left,
	], function () {
	  updateDomFunc($el, context, 'visibility', 'initial');
	});

	var instance = {
	  $el: $el,
	};
	var streams = build($el, context, function (wd) {
	  var w = measureWidth($el, wd);
	  if (instance.minWidth) {
		stream.push(instance.minWidth, w);
	  }
	  else {
		instance.initialMinWidth = w;
	  }
	}, function () {
	  var h = measureHeight($el);
	  if (instance.minHeight) {
		stream.push(instance.minHeight, h);
	  }
	  else {
		instance.initialMinHeight = h;
	  }
	}) || {};
	instance.minWidth = streams.minWidth ? streams.minWidth : stream.create();
	instance.minHeight = streams.minHeight ? streams.minHeight : stream.create();
	if (instance.hasOwnProperty('initialMinWidth')) {
	  stream.push(instance.minWidth, instance.initialMinWidth);
	}
	if (instance.hasOwnProperty('initialMinHeight')) {
	  stream.push(instance.minHeight, instance.initialMinHeight);
	}

	if (context.useMinWidth) {
	  stream.pushAll(instance.minWidth, context.width);
	}
	if (context.useMinHeight) {
	  stream.pushAll(stream.combine([
		instance.minHeight,
		context.width,
	  ], function (mh, w) {
		return mh(w);
	  }), context.height);
	}

	instance.remove = function () {
	  onRemove.map(apply());
	  $el.remove();
	};
	context.onRemove(instance.remove);

	$el.appendTo(context.$el);

	return instance;
  };

  var component = function (name) {
	return function (build) {
	  return function (context) {
		return componentFunc(name, build, context);
	  };
	};
  };

  var a = component('a');
  var button = component('button');
  var div = component('div');
  var form = component('form');
  var iframe = component('iframe');
  var img = component('img');
  var input = component('input');
  var label = component('label');
  var li = component('li');
  var option = component('option');
  var p = component('p');
  var pre = component('pre');
  var select = component('select');
  var textarea = component('textarea');
  var ul = component('ul');

  var _scrollbarWidth = function () {
	var parent, child, width;

	if(width===undefined) {
	  parent = $('<div style="width:50px;height:50px;overflow:auto"><div/></div>').appendTo('body');
	  child=parent.children();
	  width=child.innerWidth()-child.height(99).innerWidth();
	  parent.remove();
	}

	return width;
  };
  var layoutRecurse = function ($el, ctx, cs) {
	if ($.isArray(cs)) {
	  return cs.map(function (c) {
		return layoutRecurse($el, ctx, c);
	  });
	}
	else {
	  if (!$.isFunction (cs)) {
		console.log('cs is not a function');
		debugger;
	  }
	  return function (context) {
		var i = cs(context);
		// todo: replace with some isInstance function
		if (!i || !i.minWidth || !i.minHeight) {
		  console.log('not a component');
		  debugger;
		}
		return i;
	  };
	}
  };

  var layout = function (elArg, buildLayoutArg) {
	var el = buildLayoutArg ? elArg : div;
	var buildLayout = buildLayoutArg || elArg;
	return function () {
	  var args = Array.prototype.slice.call(arguments);
	  return el(function ($el, ctx) {
		$el.css('pointer-events', 'none')
		  .css('overflow', 'hidden');
		return buildLayout.apply(null, [$el, ctx].concat(layoutRecurse($el, ctx, args)));
	  });
	};
  };

  var container = function (elArg, buildContainerArg) {
	var el = buildContainerArg ? elArg : div;
	var buildContainer = buildContainerArg || elArg;
	return div(function ($el, ctx) {
	  return buildContainer($el, ctx, function (cs) {
		return layoutRecurse($el, ctx, cs);
	  });
	});
  };

  var all = function (fs) {
	return function (c) {
	  return fs.reduce(function (c, f) {
		return f(c);
	  }, c);
	};
  };

  var rootLayout = layout(function ($el, ctx, c) {
	stream.combine([
	  ctx.width,
	  ctx.height,
	  ctx.top,
	  ctx.left,
	], function () {
	  stream.push(displayedS, true);
	  updateDomFunc($('body'), ctx, 'height', 'auto');
	});
	return ctx.append(c);
  });

  var ensureSandbox = function () {
	if ($('.sandbox').length > 0) {
	  return;
	}
	$(document.createElement('div'))
	  .addClass('sandbox')
	  .css('z-index', -1)
	  .appendTo($('body'));
  };
  var countComponentsRendered = 0;
  var rootComponent = function (c, config) {
	// var debugAndRepeat = function () {
	//   debugger;
	//   stream.defer(debugAndRepeat);
	// };
	// stream.defer(debugAndRepeat);
	config = config || {};
	ensureSandbox();
	var scrollbarWidth = _scrollbarWidth();
	var width = stream.create();
	var height = stream.create();
	var minHeight = stream.create();
	stream.combine([
	  windowWidth,
	  windowHeight,
	  minHeight,
	], function (ww, wh, mh) {
	  var mhAtWW = mh(ww);
	  var mhAtScrollbarWW = mh(ww - scrollbarWidth);
	  if (document.body.scrollHeight > window.innerHeight) {
		// this if statement does not work, document.body.scrollHeight should actually be a stream
		stream.push(width, ww - scrollbarWidth);
		stream.push(height, mhAtScrollbarWW);
		return;
	  }
	  if (mhAtWW > wh) {
		if (mhAtScrollbarWW > wh) {
		  $('body').css('overflow-y', 'initial');
		  stream.push(width, ww - scrollbarWidth);
		  stream.push(height, mhAtScrollbarWW);
		}
		else {
		  $('body').css('overflow-y', 'scroll');
		  stream.push(width, ww - scrollbarWidth);
		  stream.push(height, mhAtScrollbarWW);
		}
	  }
	  else {
		$('body').css('overflow-y', 'initial');
		stream.push(width, ww);
		stream.push(height, mhAtWW);
	  }
	});
	var onRemove = [];
	var i = rootLayout(c)({
	  $el: $('body'),
	  width: width,
	  height: height,
	  top: onceZeroS,
	  left: onceZeroS,
	  topOffset: onceZeroS,
	  leftOffset: onceZeroS,
	  onRemove: onRemove.push,
	});
	i.$el.css('position', 'absolute')
	  .css('top', '0px')
	  .css('left', '0px')
	  .css('background-color', config.noBackground ? '' : 'white')
	  .addClass('root-component')
	  .addClass('root-component-' + countComponentsRendered);
	countComponentsRendered += 1;
	var elHeight = i.$el.css('height');
	stream.map(displayedS, function (displayed) {
	  if (displayed) {
		setTimeout(function () {
		  $('.server-content').css('display', 'none');
		  console.log('did it');
		  console.log('golly look at this endearing debug output');
		  $('.huge').css('display', 'none');
		}, 500);
	  }
	});
	var remove = i.remove;
	i.remove = function () {
	  onRemove.map(apply());
	  remove();
	};
	stream.pushAll(i.minHeight, minHeight);
	stream.combine([
	  width,
	  height,
	], function (w, h) {
	  i.$el.css('width', px(w))
		.css('height', px(h));
	});
	return i;
  };

  var color = function (c) {
	c = c || {};
	return {
	  r: c.hasOwnProperty('r') ? c.r : 1,
	  g: c.hasOwnProperty('g') ? c.g : 1,
	  b: c.hasOwnProperty('b') ? c.b : 1,
	  a: c.hasOwnProperty('a') ? c.a : 1,
	};
  };
  var isColor = function (x) {
	return x &&
	  x.hasOwnProperty('r') &&
	  x.hasOwnProperty('g') &&
	  x.hasOwnProperty('b') &&
	  x.hasOwnProperty('a');
  };
  var multiplyColor = function (amount) {
	return function (c) {
	  return {
		r: Math.min(255, c.r * amount),
		g: Math.min(255, c.g * amount),
		b: Math.min(255, c.b * amount),
		a: c.a,
	  };
	};
  };
  var desaturate = function (amount) {
	return function (c) {
	  var average = (c.r + c.g + c.b) / 3;
	  var coAmount = 1 - amount;
	  return {
		r: coAmount * c.r + amount * average,
		g: coAmount * c.g + amount * average,
		b: coAmount * c.b + amount * average,
		a: c.a,
	  };
	};
  };
  var colorBrightness = function (c) {
	return (c.r + c.g + c.b) / (255 + 255 + 255);
  };
  var colorString = function (c) {
	return 'rgba(' + Math.floor(c.r) + ',' + Math.floor(c.g) + ',' + Math.floor(c.b) + ',' + c.a + ')';
  };
  var rgbColorString = function (c) {
	return 'rgb(' + Math.floor(c.r) + ',' + Math.floor(c.g) + ',' + Math.floor(c.b) + ')';
  };
  var transparent = color({
	a: 0,
  });
  var black = color({
	r: 0,
	g: 0,
	b: 0,
  });
  var white = color({
	r: 255,
	g: 255,
	b: 255,
  });

  var mapMinWidths = function (is, ctx) {
	return stream.all(is.map(function (i) {
	  return i.minWidth;
	}));
  };
  var mapMinHeights = function (is, ctx) {
	return stream.all(is.map(function (i) {
	  return i.minHeight;
	}));
  };

  var url = function (str) {
	return 'url("' + str + '")';
  };

  var and = function (f) {
	return function (c) {
	  return function (ctx) {
		var i = c(ctx);
		f(i, ctx);
		return i;
	  };
	};
  };
  var $$ = function (f) {
	return and(function (i, ctx) {
	  return f(i.$el, ctx);
	});
  };
  var jqueryMethod = function (func) {
	return function () {
	  var args = Array.prototype.slice.call(arguments);
	  return $$(function ($el) {
		$el[func].apply($el, args);
	  });
	};
  };
  var $addClass = jqueryMethod('addClass');
  var $attr = jqueryMethod('attr');
  var $css = jqueryMethod('css');
  var $on = jqueryMethod('on');
  var $prop = jqueryMethod('prop');

  var useMinWidth = function (ctx, i) {
	return stream.pushAll(i.minWidth, ctx.width);
  };
  var useMinHeight = function (ctx, i) {
	return stream.combineInto([
	  ctx.width,
	  i.minHeight,
	], function (w, mh) {
	  return mh(w);
	}, ctx.height);
  };
  var minWidth = function (mw) {
	return layout(function ($el, ctx, c) {
	  $el.addClass('minWidth');
	  var i = ctx.append(c);
	  return {
		minWidth: stream.once(mw),
		minHeight: i.minHeight,
	  };
	});
  };
  var minHeight = function (mh) {
	return layout(function ($el, ctx, c) {
	  $el.addClass('minHeight');
	  var i = ctx.append(c);
	  return {
		minWidth: i.minWidth,
		minHeight: stream.once(constant(mh)),
	  };
	});
  };
  var withDimensions = function (mw, mh) {
	return layout(function ($el, ctx, c) {
	  $el.addClass('withDimensions');
	  var i = ctx.append(c);
	  return {
		minWidth: stream.once(mw),
		minHeight: stream.once(constant(mh)),
	  };
	});
  };
  var passthrough = function (f, el) {
	return layout(el || div, function ($el, ctx, c) {
	  $el.addClass('passthrough');
	  if (f) {
		f($el);
	  }
	  return ctx.append(c);
	});
  };
  var wrap = function (el) {
	return passthrough(null, el);
  };

  var adjustPosition = function (minSize, position) {
	minSize = minSize || {};
	minSize.minWidth = minSize.minWidth || id;
	minSize.minHeight = minSize.minHeight || id;
	position = position || {};
	position.top = position.top || onceZeroS;
	position.left = position.left || onceZeroS;
	position.width = position.width || id;
	position.height = position.height || id;
	return layout(function ($el, ctx, c) {
	  var context = {
		top: stream.create(),
		left: stream.create(),
		width: stream.create(),
		height: stream.create(),
	  };
	  var i = ctx.append(c, context);
	  stream.pushAll(position.top, context.top);
	  stream.pushAll(position.left, context.left);
	  stream.pushAll(stream.map(ctx.width, position.width), context.width);
	  stream.pushAll(stream.map(ctx.height, position.height), context.height);
	  return {
		minWidth: stream.map(i.minWidth, function (mw) {
		  return minSize.minWidth(mw);
		}),
		minHeight: stream.map(i.minHeight, function (mh) {
		  return minSize.minHeight(mh);
		}),
	  };
	});
  };

  var adjustMinSize = uncurryConfig(function (config) {
	return layout(function ($el, ctx, c) {
	  var i = ctx.append(c);
	  return {
		minWidth: stream.map(i.minWidth, function (mw) {
		  return config.mw(mw);
		}),
		minHeight: stream.map(i.minHeight, function (mh) {
		  return config.mh(mh);
		}),
	  };
	});
  });
  var link = all([
	$css('cursor', 'pointer'),
	$css('pointer-events', 'initial'),
  ]);

  // var componentName = function (name) {
  // 	return passthrough(function ($el) {
  // 		$el.addClass(name);
  // 	});
  // };

  var onThis = function (event) {
	return function (handler) {
	  return $on(event, handler);
	};
  };
  var changeThis = onThis('change');
  var clickThis = onThis('click');
  var inputPropertychangeThis = onThis('input propertychange');
  var keydownThis = onThis('keydown');
  var keyupThis = onThis('keyup');
  var mousedownThis = onThis('mousedown');
  var mousemoveThis = onThis('mousemove');
  var mouseoverThis = onThis('mouseover');
  var mouseoutThis = onThis('mouseout');
  var mouseupThis = onThis('mouseup');
  var submitThis = onThis('submit');

  var pushOnClick = function (s, f) {
	return clickThis(function (ev) {
	  stream.push(s, f(ev));
	});
  };

  var hoverThis = function (cb) {
	return passthrough(function ($el) {
	  cb(false, $el);
	  $el.on('mouseover', function (ev) {
		cb(true, $el, ev);
	  });
	  $el.on('mouseout', function (ev) {
		cb(false, $el, ev);
	  });
	});
  };

  var hoverStream = function (s, f) {
	f = f || function (v) {
	  return v;
	};
	return $$(function ($el) {
	  $el.css('pointer-events', 'initial');
	  $el.on('mouseover', function (ev) {
		stream.push(s, f(ev));
	  });
	  $el.on('mouseout', function (ev) {
		stream.push(s, f(false));
	  });
	});
  };

  var cssStream = function (style, valueS) {
	return passthrough(function ($el) {
	  stream.map(valueS, function (value) {
		$el.css(style, value);
	  });
	});
  };

  var backgroundColor = function (s, arg2, arg3, arg4) {
	// function may accept four arguments...
	if (isColor(s)) {
	  s = {
		background: s,
		font: arg2,
		backgroundHover: arg3,
		fontHover: arg4,
	  };
	}
	s = s || {};
	// or it may accept one object whose properties are either colors or streams...
	if (stream.isStream(s.background) ||
		stream.isStream(s.font) ||
		stream.isStream(s.backgroundHover) ||
		stream.isStream(s.fontHover)) {
	  if (s.background && !stream.isStream(s.background)) {
		s.background = stream.once(s.background);
	  }
	  if (s.font && !stream.isStream(s.font)) {
		s.font = stream.once(s.font);
	  }
	  if (s.backgroundHover && !stream.isStream(s.backgroundHover)) {
		s.backgroundHover = stream.once(s.backgroundHover);
	  }
	  if (s.fontHover && !stream.isStream(s.fontHover)) {
		s.fontHover = stream.once(s.fontHover);
	  }
	  s = stream.combineObject(s);
	}
	// or a stream.
	if (!stream.isStream(s)) {
	  s = stream.once(s);
	}
	return $$(function ($el) {
	  var bc, fc, bcHover, fcHover, hoverState = false;
	  var applyColors = function () {
		var applyBC = hoverState ? (bcHover || bc) : bc;
		var applyFC = hoverState ? (fcHover || fc) : fc;
		if (applyBC) {
		  $el.css('background-color', colorString(applyBC));
		}
		if (applyFC) {
		  $el.css('color', colorString(applyFC));
		}
	  };
	  stream.map(s, function (colors) {
		bc = colors.background;
		fc = colors.font;
		bcHover = colors.backgroundHover || bc;
		fcHover = colors.fontHover || fc;
		applyColors();
	  });
	  $el.on('mouseover', function () {
		hoverState = true;
		applyColors();
	  });
	  $el.on('mouseout', function () {
		hoverState = false;
		applyColors();
	  });
	});
  };
  var withFontColor = function (fc) {
	return passthrough(function ($el) {
	  $el.css('color', colorString(fc));
	});
  };
  var hoverColor = uncurryConfig(function (config) {
	var backgroundColor = colorString(config.backgroundColor || transparent);
	var hoverBackgroundColor = colorString(config.hoverBackgroundColor || backgroundColor);
	var fontColor = colorString(config.fontColor || black);
	var hoverFontColor = colorString(config.hoverFontColor || fontColor);
	return hoverThis(function (h, $el) {
	  $el.css('transition', 'background-color ease ' + config.transition + 's' + ', color ease ' + config.transition + 's');
	  $el.css('background-color', h ? hoverBackgroundColor : backgroundColor);
	  $el.css('color', h ? hoverFontColor : fontColor);
	});
  });

  var crop = function (amount) {
	var top = amount.all || 0,
		bottom = amount.all || 0,
		left = amount.all || 0,
		right = amount.all || 0;

	// amount may be a single number
	if ($.isNumeric(amount)) {
	  top = bottom = left = right = amount;
	}
	// or an object with properties containing 'top', 'bottom', 'left', and 'right'
	else {
	  for (var key in amount) {
		var lcKey = key.toLowerCase();
		if (amount[key] !== null) {
		  if (lcKey.indexOf('top') !== -1) {
			top = amount[key];
		  }
		  if (lcKey.indexOf('bottom') !== -1) {
			bottom = amount[key];
		  }
		  if (lcKey.indexOf('left') !== -1) {
			left = amount[key];
		  }
		  if (lcKey.indexOf('right') !== -1) {
			right = amount[key];
		  }
		}
	  }
	}
	return layout(function ($el, ctx, c) {
	  $el.addClass('crop');
	  $el.css('overflow', 'hidden');
	  var props = stream.create();
	  var i = ctx.append(c, {
		top: stream.prop(props, 'top'),
		left: stream.prop(props, 'left'),
		width: stream.prop(props, 'width'),
		height: stream.prop(props, 'height'),
	  });
	  var minWidth = stream.create();
	  var minHeight = stream.create();
	  stream.combineInto([
		i.minWidth,
		i.minHeight,
		ctx.width,
		ctx.height,
	  ], function (mw, mh, w, h) {
		var width = w / (1 - left - right);
		var height = h / (1 - top - bottom);
		return {
		  top: -top * height,
		  left: -left * width,
		  width: width,
		  height: height,
		};
	  }, props);
	  stream.combine([
		i.minWidth,
		i.minHeight,
	  ], function (mw, mh) {
		stream.push(minWidth, mw * (1 - left - right));
		stream.push(minHeight, function (w) {
		  return mh(mw / (1 - left - right)) * (1 - top - bottom);
		});
	  });
	  return {
		minWidth: minWidth,
		minHeight: minHeight,
	  };
	});
  };
  var keepAspectRatio = uncurryConfig(function (config) {
	config = config || {};
	return layout(function ($el, ctx, c) {
	  $el.addClass('keepAspectRatio');
	  $el.css('overflow', 'hidden');
	  var props = stream.create();
	  var i = ctx.append(c, {
		top: stream.prop(props, 'top'),
		left: stream.prop(props, 'left'),
		width: stream.prop(props, 'width'),
		height: stream.prop(props, 'height'),
	  });
	  stream.combineInto([
		i.minWidth,
		i.minHeight,
		ctx.width,
		ctx.height,
	  ], function (mw, mh, w, h) {
		var ar = mw / mh(mw);
		var AR = w / h;
		if (Number.isNaN(ar) || Number.isNaN(AR)) {
		  console.log('keepAspectRatio aspect ratio NaN');
		}
		// container is wider
		if ((!config.fill && AR > ar) ||
			(config.fill && AR < ar)) {
		  var usedWidth = h * ar;

		  var left;
		  if (config.left) {
			left = 0;
		  }
		  else if (config.right) {
			left = w - usedWidth;
		  }
		  else {
			left = (w - usedWidth) / 2;
		  }

		  return {
			top: 0,
			left: left,
			width: usedWidth,
			height: h,
		  };
		}
		// container is taller
		else {
		  var usedHeight = w / ar;

		  var top;
		  if (config.top) {
			top = 0;
		  }
		  else if (config.bottom) {
			top = h - usedHeight;
		  }
		  else {
			top = (h - usedHeight) / 2;
		  }

		  return {
			top: top,
			left: 0,
			width: w,
			height: usedHeight,
		  };
		}
	  }, props);
	  var minWidth = stream.create();
	  var minHeight = stream.create();
	  stream.combine([
		i.minWidth,
		i.minHeight,
	  ], function (mw, mh) {
		if (config.minWidth) {
		  stream.push(minWidth, config.minWidth);
		}
		else if (config.minHeight) {
		  stream.push(minWidth, config.minHeight * mw / mh(mw));
		}
		else {
		  stream.push(minWidth, mw);
		}
		stream.push(minHeight, function (w) {
		  return w / (mw / mh(mw));
		});
	  });
	  return {
		minWidth: minWidth,
		minHeight: minHeight,
	  };
	});
  });

  var image = function (config) {
	var srcStream = stream.isStream(config.src) ? config.src : stream.once(config.src);
	return img(function ($el, ctx) {
	  var minWidth = stream.create();
	  var minHeight = stream.create();
	  stream.map(srcStream, function (src) {
		$el.prop('src', src);
	  });
	  $el.on('load', function () {
		var aspectRatio = $el[0].naturalWidth / $el[0].naturalHeight;
		var mw = config.minWidth ||
			  (config.minHeight && config.minHeight * aspectRatio) ||
			  $el[0].naturalWidth;
		if (config.minWidth === 0 || config.minHeight === 0) {
		  mw = 0;
		}
		stream.push(minWidth, mw);
		stream.push(minHeight, function (w) {
		  return w / aspectRatio;
		});
	  });
	  return {
		minWidth: minWidth,
		minHeight: minHeight,
	  };
	});
  };

  var linkTo = uncurryConfig(function (config) {
	if ($.type(config) === 'string') {
	  config = {
		href: config,
	  };
	}
	return layout(a, function ($el, ctx, c) {
	  $el.prop('href', config.href);
	  $el.css('pointer-events', 'initial');
	  if (config.target) {
		$el.prop('target', config.target);
	  }
	  if (!config.defaultStyle) {
		$el.addClass('no-style');
	  }
	  return ctx.append(c);
	});
  });

  var empty = function (el) {
	return component(el)(function ($el, ctx) {
	  $el.addClass('empty');
	  return {
		minWidth: onceZeroS,
		minHeight: stream.once(constant(0)),
	  };
	});
  };
  var nothing = empty("div");

  var text = function (strs, config) {
	strs = strs || '';
	if (!$.isArray(strs)) {
	  strs = [strs];
	}
	config = config || strs[0];
	if ($.isArray(config)) {
	  config = config.reduce($.extend, {});
	}

	config.lineHeight = config.lineHeight || 1;

	return (config.el || div)(function ($el, ctx) {
	  var didMH = false;
	  var mwS = stream.create();
	  var mhS = stream.create();
	  var spanStreams = [];
	  $el.addClass('text');
	  strs.map(function (c, index) {
		if ($.type(c) === 'string') {
		  c = {
			str: c,
		  };
		  strs[index] = c;
		}
		if (c.font) {
		  c = $.extend(c, c.font);
		}
		if (c.fonts) {
		  c.fonts.map(function (font) {
			c = $.extend(c, font);
		  });
		}
		var $span = $(document.createElement('span'));
		var updateStr = function (str) {
		  if (index === 0) {
			str = ' ' + str;
		  }
		  if (index === strs.length - 1) {
			str = str + ' ';
		  }
		  $span.html(str);
		  c.words = str.split(' ');
		};
		if (stream.isStream(c.str)) {
		  spanStreams.push(stream.map(c.str, function (x) {
			updateStr(x);
		  }));
		}
		else {
		  updateStr(c.str);
		}
		c.size = c.size || config.size;
		var fontStyle = 'normal';
		var fontVariant = 'normal';
		var fontWeight = c.weight || config.weight || 'normal';
		var fontSize = c.size || config.size || parseInt($el.css('font-size'));
		var lineHeight = c.lineHeight || config.lineHeight || $el.css('line-height');
		var fontFamily = c.family || config.family || 'initial';
		c.font = [
		  fontStyle,
		  fontVariant,
		  fontWeight,
		  fontSize + 'px/' + lineHeight,
		  fontFamily,
		].join(' ');

		if (c.size) {
		  if (stream.isStream(c.size)) {
			spanStreams.push(stream.map(c.size, function (x) {
			  $span.css('font-size', x);
			}));
		  }
		  else {
			$span.css('font-size', c.size);
		  }
		}
		if (c.weight) {
		  if (stream.isStream(c.weight)) {
			spanStreams.push(stream.map(c.weight, function (x) {
			  $span.css('font-weight', c.x);
			}));
		  }
		  else {
			$span.css('font-weight', c.weight);
		  }
		}
		if (c.family) {
		  if (stream.isStream(c.family)) {
			spanStreams.push(stream.map(c.family, function (x) {
			  $span.css('font-family', c.x);
			}));
		  }
		  else {
			$span.css('font-family', c.family);
		  }
		}
		if (c.color) {
		  if (stream.isStream(c.color)) {
			spanStreams.push(stream.map(c.color, function (x) {
			  $span.css('color', colorString(x));
			}));
		  }
		  else {
			$span.css('color', colorString(c.color));
		  }
		}
		if (c.shadow) {
		  if (stream.isStream(c.shadow)) {
			spanStreams.push(stream.map(c.shadow, function (x) {
			  $span.css('text-shadow', c.x);
			}));
		  }
		  else {
			$span.css('text-shadow', c.shadow);
		  }
		}
		if (c.align) {
		  if (stream.isStream(c.align)) {
			spanStreams.push(stream.map(c.align, function (x) {
			  $span.css('vertical-align', c.x);
			}));
		  }
		  else {
			$span.css('vertical-align', c.align);
		  }
		}
		if (c.spanCSS) {
		  c.spanCSS.map(function (css) {
			$span.css(css.name, css.value);
		  });
		}
		if (c.linkTo) {
		  var $a = $(document.createElement('a'));
		  $a.prop('href', c.linkTo).appendTo($el);
		  $span.appendTo($a);
		}
		else {
		  $span.appendTo($el);
		}
	  });
	  var firstPush = true;
	  var pushDimensions = function () {
		stream.next(function () {
		  // var mw = (config.hasOwnProperty('minWidth') && config.minWidth) ||
		  // 		(config.measureWidth && strs.reduce(function (a, c, index) {
		  // 		  var width = measureTextWidth(c.str, c.font);
		  // 		  return a + width;
		  // 		}, 0)) ||
		  // 		300;
		  var mw = config.minWidth ||
		  		(config.measureWidth && measureWidth($el)) ||
		  		300;
		  var mh = (config.oneLine && $el.css('line-height').indexOf('px') !== -1 && constant(parseFloat($el.css('line-height')))) || function (w) {
			// TODO: loop over spans
			var fontSize = config.size || parseInt($el.css('font-size'));
			var str = $el.text();
			var lineHeight = config.lineHeight;
			return Math.ceil(fontSize * str.length * 0.5 / w) * fontSize * config.lineHeight;
		  };
		  if (!config.oneLine) {
			stream.defer(function () {
			  var mh = (config.minHeight && constant(config.minHeight)) ||
					measureHeight($el);
					// measureTextHeight(strs.map(function (c) {
					//   return {
					// 	words: c.words.slice(0),
					// 	font: c.font,
					// 	size: c.size || config.size,
					//   };
					// }), config.lineHeight);
			  stream.push(mhS, mh);
			});
		  }
		  stream.push(mwS, mw);
		  if (config.oneLine || config.approximateHeight) {
			stream.push(mhS, mh);
		  }
		  firstPush = false;
		});
	  };
	  if (spanStreams.length > 0) {
		stream.combine(spanStreams, function () {
		  pushDimensions();
		});
	  }
	  if (config.size) {
		if (stream.isStream(config.size)) {
		  stream.map(config.size, function (size) {
			$el.css('font-size', size);
			pushDimensions();
		  });
		}
		else {
		  $el.css('font-size', config.size);
		}
	  }
	  if (config.weight) {
		if (stream.isStream(config.weight)) {
		  stream.map(config.weight, function (weight) {
			$el.css('font-weight', weight);
			pushDimensions();
		  });
		}
		else {
		  $el.css('font-weight', config.weight);
		}
	  }
	  if (config.family) {
		if (stream.isStream(config.family)) {
		  stream.map(config.family, function (family) {
			$el.css('font-family', family);
			pushDimensions();
		  });
		}
		else {
		  $el.css('font-family', config.family);
		}
	  }
	  if (config.color) {
		if (stream.isStream(config.color)) {
		  stream.map(config.color, function (color) {
			$el.css('color', colorString(color));
			pushDimensions();
		  });
		}
		else {
		  $el.css('color', colorString(config.color));
		}
	  }
	  if (config.shadow) {
		if (stream.isStream(config.shadow)) {
		  stream.map(config.shadow, function (shadow) {
			$el.css('text-shadow', shadow);
			pushDimensions();
		  });
		}
		else {
		  $el.css('text-shadow', config.shadow);
		}
	  }
	  if (config.align) {
		if (stream.isStream(config.align)) {
		  stream.map(config.align, function (align) {
			$el.css('text-align', align);
			pushDimensions();
		  });
		}
		else {
		  $el.css('text-align', config.align);
		}
	  }

	  // if (config.minWidth) {
	  // 	stream.push(mw, config.minWidth);
	  // }
	  // else if (config.measureWidth) {
	  // 	stream.push(mw, measureWidth($el));
	  // }
	  // else {
	  // 	stream.push(mw, 0);
	  // }

	  // if (config.minHeight) {
	  // 	stream.push(mh, config.minHeight);
	  // }
	  // else if (config.measureHeight) {
	  // 	stream.push(mh, measureHeight($el));
	  // }
	  // else {
	  // 	stream.push(mh, constant(0));
	  // }

	  pushDimensions();

	  return {
		minWidth: mwS,
		minHeight: mhS,
	  };
	});
  };

  var ignoreSurplusWidth = function (_, cols) {
	return cols;
  };
  var ignoreSurplusHeight = function (_, rows) {
	return rows;
  };
  var centerSurplusWidth = function (gridWidth, positions) {
	var lastPosition = positions[positions.length - 1];
	var surplusWidth = gridWidth - (lastPosition.left + lastPosition.width);
	var widthPerCol = surplusWidth / positions.length;
	positions.map(function (position, i) {
	  position.left += surplusWidth / 2;
	});
	return positions;
  };
  var evenlySplitSurplusWidth = function (gridWidth, positions) {
	var lastPosition = positions[positions.length - 1];
	var surplusWidth = gridWidth - (lastPosition.left + lastPosition.width);
	var widthPerCol = surplusWidth / positions.length;
	positions.map(function (position, i) {
	  position.width += widthPerCol;
	  position.left += i * widthPerCol;
	});
	return positions;
  };
  var evenlySplitCenterSurplusWidth = function (gridWidth, positions) {
	var lastPosition = positions[positions.length - 1];
	var surplusWidth = gridWidth - (lastPosition.left + lastPosition.width);
	var widthPerCol = surplusWidth / positions.length;
	positions.map(function (position, i) {
	  position.left += (i + 0.5) * widthPerCol;
	});
	return positions;
  };
  var centerAllSameSurplusWidth = function () {
	var w = 0;
	return function (gridWidth, positions, _, i) {
	  if (i === 0) {
		positions = evenlySplitSurplusWidth(gridWidth, positions);
		w = positions[0].width;
		return positions;
	  }
	  else {
		positions.map(function (position, i) {
		  position.width = w;
		  position.left = w * i;
		});
		return centerSurplusWidth(gridWidth, positions);
	  }
	};
  };
  var centerFirstRowThenAlignLeftSurplusWidth = function () {
	var left = 0;
	return function (gridWidth, positions, i) {
	  if (i === 0) {
		positions = centerSurplusWidth(gridWidth, positions);
		left = positions[0].left;
		return positions;
	  }
	  else {
		positions.map(function (position, i) {
		  position.left += left;
		});
		return positions;
	  }
	};
  };
  // don't read this function, please
  var evenlySplitSurplusWidthWithMinPerRow = function (minPerRow) {
	return function (gridWidth, positions) {
	  var lastPosition = positions[positions.length - 1];
	  var surplusWidth = gridWidth - (lastPosition.left + lastPosition.width);
	  var widthPerCol = gridWidth / Math.max(minPerRow, positions.length);
	  positions.map(function (position, i) {
		position.width = widthPerCol;
		position.left = i * widthPerCol;
	  });
	  lastPosition = positions[positions.length - 1];
	  surplusWidth = gridWidth - (lastPosition.left + lastPosition.width);
	  widthPerCol = surplusWidth / positions.length;
	  positions.map(function (position, i) {
		position.left += surplusWidth / 2;
	  });
	  return positions;
	};
  };
  var justifySurplusWidth = function (gridWidth, positions) {
	var lastPosition = positions[positions.length - 1];
	var surplusWidth = gridWidth - (lastPosition.left + lastPosition.width);
	positions.map(function (position, i) {
	  for (var index = 0; index < i; index++) {
		position.left += surplusWidth / (positions.length - 1);
	  }
	});
	return positions;
  };
  var justifyAndCenterSurplusWidth = function (gridWidth, positions) {
	var lastPosition = positions[positions.length - 1];
	var surplusWidth = gridWidth - (lastPosition.left + lastPosition.width);
	positions.map(function (position, i) {
	  position.left += i * surplusWidth / (positions.length) +
		surplusWidth / (2 * positions.length);
	});
	return positions;
  };
  var surplusWidthAlign = function (t) {
	return function (gridWidth, positions) {
	  var lastPosition = positions[positions.length - 1];
	  var surplusWidth = gridWidth - (lastPosition.left + lastPosition.width);
	  positions.map(function (position, i) {
		position.left += t * surplusWidth;
	  });
	  return positions;
	};
  };
  var surplusWidthAlignLeft = surplusWidthAlign(0);
  var surplusWidthAlignCenter = surplusWidthAlign(0.5);
  var surplusWidthAlignRight = surplusWidthAlign(1);
  var superSurplusWidth = function (gridWidth, positions) {
	var lastPosition = positions[positions.length - 1];
	var surplusWidth = gridWidth - (lastPosition.left + lastPosition.width);
	if (positions.length === 1) {
	  // if we're the only thing on the row, stretch up to roughly
	  // double our min width
	  if (surplusWidth < positions[0].width) {
		return evenlySplitSurplusWidth(gridWidth, positions);
	  }
	  else {
		return positions;
	  }
	}
	if (positions.length === 2) {
	  // if there are two things in the row, make two columns each
	  // with centered content
	  return justifyAndCenterSurplusWidth(gridWidth, positions);
	}
	// if there are 3+ things in the row, then justify
	return justifySurplusWidth(gridWidth, positions);
  };

  var giveToNth = function (n) {
	return function (gridWidth, positions) {
	  var lastPosition = positions[positions.length - 1];
	  var surplusWidth = gridWidth - (lastPosition.left + lastPosition.width);
	  positions.map(function (position, i) {
		if (i === n || (i === positions.length - 1 && n >= positions.length)) {
		  position.width += surplusWidth;
		}
		else if (i > n) {
		  position.left += surplusWidth;
		}
	  });
	  return positions;
	};
  };
  var giveToFirst = giveToNth(0);
  var giveToSecond = giveToNth(1);
  var giveToThird = giveToNth(2);

  var centerSurplusHeight = function (totalHeight, positions) {
	var lastPosition = positions[positions.length - 1];
	var surplusHeight = totalHeight - (lastPosition.top + lastPosition.height);
	positions.map(function (position, i) {
	  position.top += surplusHeight / 2;
	});
	return positions;
  };
  var evenlySplitSurplusHeight = function (totalHeight, positions) {
	var lastPosition = positions[positions.length - 1];
	var surplusHeight = totalHeight - (lastPosition.top + lastPosition.height);
	var heightPerCol = surplusHeight / positions.length;
	positions.map(function (position, i) {
	  position.height += heightPerCol;
	  position.top += i * heightPerCol;
	});
	return positions;
  };
  var giveHeightToNth = function (n) {
	return function (totalHeight, positions) {
	  var lastPosition = positions[positions.length - 1];
	  var surplusHeight = totalHeight - (lastPosition.top + lastPosition.height);
	  positions.map(function (position, i) {
		if (i === n || (i === positions.length - 1 && n >= positions.length)) {
		  position.height += surplusHeight;
		}
		else if (i > n) {
		  position.top += surplusHeight;
		}
	  });
	  return positions;
	};
  };
  var giveHeightToLast = function (totalHeight, positions) {
	var n = positions.length - 1;
	var lastPosition = positions[positions.length - 1];
	var surplusHeight = totalHeight - (lastPosition.top + lastPosition.height);
	positions.map(function (position, i) {
	  if (i === n || (i === positions.length - 1 && n >= positions.length)) {
		position.height += surplusHeight;
	  }
	  else if (i > n) {
		position.top += surplusHeight;
	  }
	});
	return positions;
  };

  var slideshow = uncurryConfig(function (config) {
	config.padding = config.padding || 0;
	config.transitionTime = config.transitionTime || 0;
	return layout(function ($el, ctx, cs) {
	  $el.css('overflow', 'hidden');
	  $el.addClass('slideshow');

	  var contexts = cs.concat(cs).concat(cs).map(function () {
		return {
		  left: stream.create(),
		};
	  });
	  var is = cs.concat(cs).concat(cs).map(function (c, index) {
		return ctx.append(c, contexts[index]);
	  });

	  // the state
	  var segmentOrder = [0, 1, 2];

	  var findSegment = function (index) {
		return modulo(Math.floor((index + cs.length) / cs.length), 3);
	  };

	  var allMinWidths = mapMinWidths(is);
	  var allMinHeights = mapMinHeights(is);

	  var computePositions = function (selected, width, mws, mhs, warpIndex) {
		return mws.map(function (mw, index) {
		  var thisSegment = Math.floor(index / cs.length);
		  var thisSegmentIndex = segmentOrder.indexOf(thisSegment);
		  var offset = modulo(index, cs.length) - modulo(selected, cs.length);
		  return {
			left: (offset + (thisSegmentIndex - 1) * cs.length) * (width + config.padding),
			warp: thisSegmentIndex === warpIndex,
		  };
		});
	  };

	  var moveSlideshow = function (positions, selectedIndex, teleport, cb) {
		positions.map(function (position, index) {
		  var ctx = contexts[index];
		  is[index].$el.css('transition', position.warp ? '' : 'left ease ' + config.transitionTime + 's');
		  stream.push(ctx.left, position.left);
		});
		cb && setTimeout(function () {
		  cb();
		}, 500);
	  };

	  var modulo = function (a, b) {
		return ((a % b) + b) % b;
	  };

	  var selectedIndexS = stream.reduce(config.moveS, function (a, b) {
		return a + b.amount;
	  }, 0);
	  var minHeight = stream.combine([
		selectedIndexS,
		ctx.width,
		allMinWidths,
		allMinHeights,
	  ], function (selectedIndex, width, mws, mhs) {
		var selectedIndexModuloCs = modulo(selectedIndex, cs.length);
		var targetSegment = findSegment(selectedIndex);
		var targetSegmentIndex = segmentOrder.indexOf(targetSegment);
		var positions;
		switch (targetSegmentIndex) {
		case 0:
		  segmentOrder = [
			segmentOrder[2],
			segmentOrder[0],
			segmentOrder[1],
		  ];
		  positions = computePositions(selectedIndexModuloCs + cs.length, width, mws, mhs, 0);
		  moveSlideshow(positions, selectedIndexModuloCs + cs.length);
		  break;
		case 1:
		  positions = computePositions(selectedIndexModuloCs + cs.length, width, mws, mhs);
		  moveSlideshow(positions, selectedIndexModuloCs + cs.length);
		  break;
		case 2:
		  segmentOrder = [
			segmentOrder[1],
			segmentOrder[2],
			segmentOrder[0],
		  ];
		  positions = computePositions(selectedIndexModuloCs + cs.length, width, mws, mhs, 2);
		  moveSlideshow(positions, selectedIndexModuloCs + cs.length);
		  break;
		}
		return constant(mhs.map(function (mh, i) {
		  return mh(width);
		}).reduce(mathMax, 0));
	  });
	  stream.push(minHeight, constant(0));

	  return {
		minWidth: stream.map(allMinWidths, function (mws) {
		  return mws.reduce(add, config.padding * (is.length - 1));
		}),
		minHeight: minHeight,
	  };
	});
  });
  // var slideshowVertical = function (config, cs) {
  // 	config.padding = config.padding || 0;
  // 	config.topTransition = config.topTransition || 'none';
  // 	config.alwaysFullHeight = config.alwaysFullHeight || false;
  // 	return div.all([
  // 		$css('overflow', 'hidden'),
  // 		componentName('slideshow'),
  // 		children(cs.map(function (c) {
  // 			return c.all([
  // 				$css('transition', 'top ' + config.topTransition),
  // 			]);
  // 		})),
  // 		wireChildren(function (instance, context, is) {
  // 			var allMinWidths = mapMinWidths(is, ctx);
  // 			var allMinHeights = mapMinHeights(is, ctx);

  // 			allMinWidths.map(function (mws) {
  // 				return mws.reduce(mathMax, 0);
  // 			}, instance.minWidth);

  // 			stream.combine([
  // 				context.width,
  // 				allMinHeights,
  // 			], function (w, mhs) {
  // 				stream.push(instance.minHeight, mhs.map(apply(w)).reduce(mathMax, 0));
  // 			});

  // 			var contexts = is.map(function (i) {
  // 				return {
  // 					top: stream.create(),
  // 					left: stream.once(0),
  // 					width: context.width,
  // 					height: i.minHeight,
  // 				};
  // 			});

  // 			stream.combine([
  // 				config.selected,
  // 				context.width,
  // 				context.height,
  // 				allMinWidths,
  // 				allMinHeights,
  // 			], function (selected, width, height, mws, mhs) {
  // 				var selectedTop = 0;
  // 				var selectedHeight = 0;
  // 				var top = 0;
  // 				var positions = mhs.map(function (mh, index) {
  // 					mh = config.alwaysFullHeight ? height : mh(width);
  // 					if (selected === index) {
  // 						selectedTop = top + config.padding * index;
  // 						selectedHeight = mh;
  // 					}
  // 					var position = {
  // 						top: top + config.padding * index,
  // 						height: mh
  // 					};
  // 					top += mh;
  // 					return position;
  // 				});
  // 				var dTop = (height - selectedHeight) / 2 - selectedTop;
  // 				positions.map(function (position) {
  // 					position.top += dTop;
  // 				});

  // 				positions.map(function (position, index) {
  // 					var ctx = contexts[index];
  // 					stream.push(ctx.top, position.top);
  // 					stream.push(ctx.height, position.height);
  // 				});
  // 			});

  // 			return [contexts];
  // 		}),
  // 	]);
  // };

  var sideBySide = uncurryConfig(function (config) {
	config = config || {};
	config.padding = config.padding || 0;
	config.surplusWidthFunc = config.surplusWidthFunc || ignoreSurplusWidth;
	return layout(function ($el, ctx, cs) {
	  $el.addClass('sideBySide');
	  if (cs.length === 0) {
		return {
		  minWidth: stream.once(0),
		  minHeight: stream.once(constant(0)),
		};
	  }
	  var contexts = [];
	  var is = cs.map(function (c) {
		var context = {
		  left: stream.create(),
		  width: stream.create(),
		};
		contexts.push(context);
		return ctx.append(c, context);
	  });
	  var allMinWidths = mapMinWidths(is, ctx);
	  var allMinHeights = mapMinHeights(is, ctx);
	  var minHeightStreams = [allMinHeights];
	  var computePositions = function (width, mws) {
		var left = 0;
		var positions = mws.map(function (mw, index) {
		  var w = Math.min(width, mw);
		  var position = {
			left: left + config.padding * index,
			width: w,
		  };
		  left += w;
		  return position;
		});
		positions = config.surplusWidthFunc(width, positions);
		return positions;
	  };
	  stream.combine([
		ctx.width,
		allMinWidths,
		allMinHeights,
		config.sourcePositionsS || stream.once([]),
	  ], function (width, mws, mhs, sourcePositions) {
		var positions = computePositions(width, mws);
		if (config.targetPositionsS) {
		  stream.push(config.targetPositionsS, positions);
		}
		sourcePositions.map(function (position, index) {
		  positions[index] = position;
		});
		positions.map(function (position, index) {
		  var ctx = contexts[index];
		  stream.push(ctx.left, position.left);
		  stream.push(ctx.width, position.width);
		});
	  });
	  return {
		minWidth: stream.map(allMinWidths, function (mws) {
		  return mws.reduce(add, config.padding * (is.length - 1));
		}),
		minHeight: stream.combine([
		  allMinWidths,
		  allMinHeights,
		], function (mws, mhs) {
		  return function (w) {
			var positions = computePositions(w, mws);
			return positions.map(function (position, i) {
			  return mhs[i](positions[i].width);
			}).reduce(mathMax, 0);
		  };
		}),
	  };
	});
  });

  var slideIn = uncurryConfig(function (config) {
	config = config || {};
	config.top = config.top || 50;
	config.transition = config.transition || '1s';
	return layout(function ($el, ctx, c) {
	  var context = {
		top: stream.create(),
	  };
	  var i = ctx.append(c, context);
	  i.$el.css('transition', 'top ' + config.transition);
	  var pushed = false;
	  stream.push(context.top, config.top);
	  stream.combine([
		ctx.topOffset,
		ctx.top,
		windowHeight,
		windowScroll,
		displayedS,
	  ], function (ta, t, wh, ws, d) {
		if (!pushed && d) {
		  var top = ta + t;
		  var visibleUntil = ws + wh;
		  if (top <= visibleUntil) {
			stream.push(context.top, 0);
			pushed = true;
		  }
		}
	  });
	  return {
		minWidth: i.minWidth,
		minHeight: i.minHeight,
	  };
	});
  });
  var fadeIn = uncurryConfig(function (config) {
	config = config || {};
	config.transition = config.transition || '1s';
	config.margin = config.margin || 0;
	return layout(function ($el, ctx, c) {
	  var i = ctx.append(c);
	  var pushed = false;
	  i.$el.css('opacity', 0);
	  setTimeout(function () {
		i.$el.css('transition', 'opacity ' + config.transition);
	  });
	  stream.combine([
		ctx.topOffset,
		ctx.top,
		windowHeight,
		windowScroll,
		displayedS,
	  ], function (ta, t, wh, ws, d) {
		if (!pushed && d) {
		  var top = ta + t;
		  var visibleUntil = ws + wh;
		  if (top + config.margin <= visibleUntil) {
			i.$el.css('opacity', 1);
			pushed = true;
		  }
		}
	  });
	  return {
		minWidth: i.minWidth,
		minHeight: i.minHeight,
	  };
	});
  });

  var slider = uncurryConfig(function (config, cs) {
	config = config || {};
	config.leftTransition = config.leftTransition || '0s';
	var grabbedS = stream.once(false);
	var edge = {
	  left: 'left',
	  right: 'right',
	};
	var stateS = stream.once({
	  index: 0,
	  edge: 'left',
	});
	var xCoord = 0;
	return layout(function ($el, ctx, cs) {
	  $el.addClass('slider')
		.css('overflow-x', 'hidden')
		.css('cursor', 'move');

	  var allMinWidths = stream.create();
	  var allMinHeights = stream.create();

	  var leftS = stream.combine([
		ctx.width,
		allMinWidths,
		stateS,
		grabbedS
	  ], function (width, mws, state, grabbed) {
		// configure left to be the left parameter of the first article in the slider
		var left = state.edge === 'left' ? 0 : width; // would love to case split
		mws.map(function (mw, index) {
		  if (index < state.index) {
			left -= mw;
		  }
		  if (state.edge === 'right' && index === state.index) {
			left -= mw;
		  }
		});
		if (grabbed !== false) {
		  left += grabbed;
		}
		return left;
	  });

	  var leftsS = stream.combine([
		allMinWidths,
		leftS,
	  ], function (mws, left) {
		return mws.reduce(function (acc, v) {
		  acc.arr.push(acc.lastValue);
		  acc.lastValue += v;
		  return acc;
		}, {
		  arr: [],
		  lastValue: left,
		}).arr;
	  });

	  var ctxs = cs.map(function (_, index) {
		return {
		  top: stream.once(0),
		  left: stream.map(leftsS, function (lefts) {
			return lefts[index];
		  }),
		  width: stream.create(),
		  height: ctx.height,
		};
	  });
	  var is = cs.map(function (c, index) {
		var i = ctx.append(c, ctxs[index]);
		stream.pushAll(i.minWidth, ctx.width);
		return i;
	  });
	  stream.pushAll(mapMinWidths(is, ctx), allMinWidths);
	  stream.pushAll(mapMinHeights(is, ctx), allMinHeights);

	  var totalMinWidthS = stream.map(allMinWidths, function (mws) {
		return mws.reduce(add, 0);
	  });

	  $el.css('user-select', 'none');
	  $el.on('mousedown', function (ev) {
		ev.preventDefault();
		stream.push(grabbedS, 0);
		is.map(function (i) {
		  i.$el.css('transition', 'left 0s');
		});
	  });

	  var release = function (ev) {
		is.map(function (i) {
		  i.$el.css('transition', 'left ' + config.leftTransition);
		});
		var mws = allMinWidths.lastValue;
		var width = ctx.width.lastValue;
		var grabbed = grabbedS.lastValue;
		if (!grabbed) {
		  return;
		}
		var left = leftS.lastValue;
		// array of sums of min widths
		var edgeScrollPoints = mws.reduce(function (a, mw) {
		  var last = a[a.length - 1];
		  a.push(last - mw);
		  return a;
		}, [0]);
		var closest = edgeScrollPoints.reduce(function (a, scrollPoint, index) {
		  var leftDistanceHere = Math.abs(scrollPoint - left);
		  var rightDistanceHere = Math.abs(scrollPoint - (left - width));
		  return {
			left: leftDistanceHere < a.left.distance ? {
			  distance: leftDistanceHere,
			  index: index,
			} : a.left,
			right: rightDistanceHere < a.right.distance ? {
			  distance: rightDistanceHere,
			  index: index - 1,
			} : a.right,
		  };
		}, {
		  left: {
			distance: Number.MAX_VALUE,
			index: -1,
		  },
		  right: {
			distance: Number.MAX_VALUE,
			index: -1,
		  },
		});
		if (closest.left.distance <= closest.right.distance) {
		  stream.push(stateS, {
			index: closest.left.index,
			edge: 'left',
		  });
		}
		else {
		  stream.push(stateS, {
			index: closest.right.index,
			edge: 'right',
		  });
		}
		stream.push(grabbedS, false);
		ev.preventDefault();
	  };
	  $el.on('mouseup', release);
	  $el.on('mouseout', release);
	  $el.on('mousemove', function (ev) {
		var grabbed = grabbedS.lastValue;
		var totalMinWidth = totalMinWidthS.lastValue;
		var width = ctx.width.lastValue;
		var left = leftS.lastValue;
		if (grabbed !== false) {
		  var dx = ev.clientX - xCoord;
		  var left2 = left + dx;
		  left2 = Math.min(0, left2);
		  if (totalMinWidth > width) {
			left2 = Math.max(width - totalMinWidth, left2);
		  }
		  dx = left2 - left;
		  grabbed = grabbed + dx;
		  stream.push(grabbedS, grabbed);
		}
		xCoord = ev.clientX;
	  });

	  return {
		minWidth: stream.map(allMinWidths, function (mws) {
		  return mws.reduce(mathMax, 0);
		}),
		minHeight: stream.combine([
		  allMinWidths,
		  allMinHeights,
		], function (mws, mhs) {
		  return constant(mhs.map(function (mh, i) {
			return mh(mws[i]);
		  }).reduce(mathMax, 0));
		}),
	  };
	});
  });

  var stack = uncurryConfig(function (config) {
	config = config || {};
	config.padding = config.padding || 0;
	config.surplusHeightFunc = config.surplusHeightFunc || ignoreSurplusHeight;
	config.collapsePadding = config.collapsePadding || false;
	config.transition = config.transition || 0;
	return layout(function ($el, ctx, cs) {
	  $el.addClass('stack');
	  if (cs.length === 0) {
		return {
		  minWidth: stream.once(0),
		  minHeight: stream.once(constant(0)),
		};
	  }
	  var contexts = [];
	  var is = cs.map(function (c) {
		var context = {
		  widthCss: stream.once('100%'),
		  top: stream.create(),
		  height: stream.create(),
		};
		contexts.push(context);
		return ctx.append(c, context);
	  });
	  if (config.transition) {
		var transition = config.transition + 's';
		is.map(function (i) {
		  i.$el.css('transition', 'height ' + transition + ', top ' + transition);
		});
	  }
	  var allMinWidths = mapMinWidths(is);
	  var allMinHeights = mapMinHeights(is);
	  stream.combine([
		ctx.width,
		ctx.height,
		allMinHeights,
	  ], function (width, height, mhs) {
		var top = 0;
		var positions = mhs.map(function (mh, index) {
		  var position = {
			top: top,
			height: mh(width),
		  };
		  var minHeight = mh(width);
		  if (config.collapsePadding) {
			if (minHeight > 0) {
			  top += minHeight + config.padding;
			}
		  }
		  else {
			top += minHeight + config.padding;
		  }
		  return position;
		});
		positions = config.surplusHeightFunc(height, positions);
		positions.map(function (position, index) {
		  var context = contexts[index];
		  stream.push(context.top, position.top);
		  stream.push(context.height, position.height);
		});
	  });
	  return {
		minWidth: stream.map(allMinWidths, function (mws) {
		  return mws.reduce(mathMax, 0);
		}),
		minHeight: stream.map(allMinHeights, function (mhs) {
		  return function (w) {
			var minHeights = mhs.map(apply(w));
			return minHeights.reduce(add, config.padding * (minHeights.filter(function (x) {
			  return !config.collapsePadding || x > 0;
			}).length - 1));
		  };
		}),
	  };
	});
  });

  var stackStream = uncurryConfig(function (config) {
	config = config || {};
	config.padding = config.padding || 0;
	config.surplusHeightFunc = config.surplusHeightFunc || ignoreSurplusHeight;
	config.transition = config.transition || 0;
	return function (actionS) {
	  return container(function ($el, ctx, child) {
		var mw = stream.once(0);
		var mh = stream.once(constant(0));
		var contexts = [];
		var is = [];
		var mwDeleteListeners = [];
		var mhDeleteListeners = [];
		var tryPushContexts = function () {
		  var width = ctx.width.lastValue;
		  var height = ctx.height.lastValue;
		  var mws = [];
		  var mhs = [];
		  is.map(function (i, index) {
			mws[index] = i.minWidth.lastValue;
			mhs[index] = i.minHeight.lastValue;
		  });
		  // if children have all provided mws and mhs, then provide mw and mh
		  if (!mws.concat(mhs).reduce(function (a, b) {
			return a && b !== undefined;
		  }, true)) {
			return;
		  }
		  stream.push(mw, mws.reduce(mathMax, 0));
		  stream.push(mh, function (w) {
			return mhs.map(apply(w)).reduce(add, config.padding * (is.length - 1));
		  });
		  // if width and height from context, then position children
		  if (width === undefined) {
			return;
		  }
		  if (height === undefined) {
			return;
		  }
		  var top = 0;
		  var idx = -1;
		  var positions = mhs.map(function (mh) {
			idx += 1;
			var position = {
			  top: top + config.padding * idx,
			  height: mh(width),
			};
			top += mh(width);
			return position;
		  });
		  positions = config.surplusHeightFunc(height, positions);
		  contexts.map(function (context, index) {
			var position = positions[index];
			stream.push(context.top, position.top);
			stream.push(context.height, position.height);
		  });
		};
		stream.onValue(ctx.width, tryPushContexts);
		stream.onValue(ctx.height, tryPushContexts);
		var cs = [];
		var index = -1;
		var insert = function (c, idx) {
		  for (var ii = cs.length; ii > idx; ii--) {
			cs[ii+1] = cs[ii];
			mwDeleteListeners[ii+1] = mwDeleteListeners[ii];
			mhDeleteListeners[ii+1] = mhDeleteListeners[ii];
			contexts[ii+1] = contexts[ii];
			is[ii+1] = is[ii];
		  }
		  index += 1;
		  var context = {
			top: stream.create(),
			height: stream.create(),
		  };
		  var i = ctx.append(child(c), context);

		  cs[index] = c;
		  mwDeleteListeners[index] = stream.onValue(i.minWidth, tryPushContexts);
		  mhDeleteListeners[index] = stream.onValue(i.minHeight, tryPushContexts);
		  contexts[index] = context;
		  is[index] = i;

		  return index;
		};
		var remove = function (c) {
		  var index = cs.indexOf(c);
		  is[index].remove();
		  mwDeleteListeners[index]();
		  mhDeleteListeners[index]();
		  delete cs[index];
		  delete mwDeleteListeners[index];
		  delete mhDeleteListeners[index];
		  delete contexts[index];
		  delete is[index];
		  tryPushContexts();
		};
		stream.onValue(actionS, function (action) {
		  caseSplit({
			insert: insert,
			insertMany: function (cs) {
			  cs.map(insert);
			},
			remove: remove,
		  }, action);
		});
		return {
		  minWidth: mw,
		  minHeight: mh,
		};
	  });
	};
  });

  var tree = uncurryConfig(function (config, index) {
	config = config || {};
	config.indent = config.indent || 10;
	return function (actionS) {
	  var expandedS = stream.once(true);
	  return sideBySide()([
		componentStream(stream.map(expandedS, function (e) {
		})),
		stackStream(config)(stream.map(actionS, caseSplit({
		  expand: function (c, i) {
		  },
		  collapse: function (i) {
		  },
		}))),
	  ]);
	};
  });

  var intersperse = function (arr, v) {
	var result = [];
	arr.map(function (el) {
	  result.push(el);
	  result.push(v);
	});
	result.pop();
	return result;
  };


  var margin = function (amount) {
	var top = amount.all || 0,
		bottom = amount.all || 0,
		left = amount.all || 0,
		right = amount.all || 0;

	// amount may be a single number
	if ($.isNumeric(amount)) {
	  top = bottom = left = right = amount;
	}
	// or an object with properties containing 'top', 'bottom', 'left', and 'right'
	else {
	  for (var key in amount) {
		var lcKey = key.toLowerCase();
		if (amount[key] !== null) {
		  if (lcKey.indexOf('top') !== -1) {
			top = amount[key] || 0;
		  }
		  if (lcKey.indexOf('bottom') !== -1) {
			bottom = amount[key] || 0;
		  }
		  if (lcKey.indexOf('left') !== -1) {
			left = amount[key] || 0;
		  }
		  if (lcKey.indexOf('right') !== -1) {
			right = amount[key] || 0;
		  }
		}
	  }
	}
	return layout(function ($el, ctx, c) {
	  $el.addClass('margin');
	  var i = ctx.append(c, {
		top: stream.once(top),
		left: stream.once(left),
		width: stream.map(ctx.width, function (w) {
		  return w - left - right;
		}),
		height: stream.map(ctx.height, function (h) {
		  return h - top - bottom;
		}),
		widthCss: stream.once('calc(100% - ' + px(left + right) + ')'),
		heightCss: stream.once('calc(100% - ' + px(top + bottom) + ')'),
	  });
	  return {
		minWidth: stream.map(i.minWidth, function (mw) {
		  return mw + left + right;
		}),
		minHeight: stream.map(i.minHeight, function (mh) {
		  return function (w) {
			return mh(w - left - right) + top + bottom;
		  };
		}),
	  };
	});
  };

  // TODO: change this name quick, before there are too many
  // dependencies on it
  var expandoStream = function (amountS) {
	var topS = stream.create();
	var bottomS = stream.create();
	var leftS = stream.create();
	var rightS = stream.create();
	stream.map(amountS, function (amount) {
	  var top = amount.all || 0,
		  bottom = amount.all || 0,
		  left = amount.all || 0,
		  right = amount.all || 0;

	  // amount may be a single number
	  if ($.isNumeric(amount)) {
		top = bottom = left = right = amount;
	  }
	  // or an object with properties containing 'top', 'bottom', 'left', and 'right'
	  else {
		for (var key in amount) {
		  var lcKey = key.toLowerCase();
		  if (amount[key] !== null) {
			if (lcKey.indexOf('top') !== -1) {
			  top = amount[key];
			}
			if (lcKey.indexOf('bottom') !== -1) {
			  bottom = amount[key];
			}
			if (lcKey.indexOf('left') !== -1) {
			  left = amount[key];
			}
			if (lcKey.indexOf('right') !== -1) {
			  right = amount[key];
			}
		  }
		}
	  }
	  stream.push(topS, top);
	  stream.push(bottomS, bottom);
	  stream.push(leftS, left);
	  stream.push(rightS, right);
	});
	return layout(function ($el, ctx, c) {
	  var i = ctx.append(c, {
		top: topS,
		left: leftS,
		height: stream.combine([
		  ctx.height,
		  topS,
		  bottomS,
		], function (h, t, b) {
		  return h - t - b;
		}),
		width: stream.combine([
		  ctx.width,
		  leftS,
		  rightS,
		], function (w, l, r) {
		  return w - l - r;
		}),
	  });
	  return {
		minWidth: stream.combine([
		  i.minWidth,
		  leftS,
		  rightS,
		], function (mw, l, r) {
		  return mw + l + r;
		}),
		minHeight: stream.combine([
		  i.minHeight,
		  topS,
		  bottomS,
		], function (mh, t, b) {
		  return function (w) {
			return mh(w) + t + b;
		  };
		}),
	  };
	});
  };

  var alignLRM = uncurryConfig(function (config) {
	config = config || {};
	config.transition = (config.transition || 0) + 's';
	return function (lrm) {
	  return layout(function ($el, ctx, l, r, m) {
		$el.addClass('alignLRM');
		var lCtx = {
		  width: stream.create(),
		};
		var rCtx = {
		  width: stream.create(),
		  left: stream.create(),
		};
		var mCtx = {
		  width: stream.create(),
		  left: stream.create(),
		};
		var lI = ctx.append(l, lCtx);
		var rI = ctx.append(r, rCtx);
		var mI = ctx.append(m, mCtx);
		stream.combine([
		  lI.minWidth,
		  rI.minWidth,
		  mI.minWidth,
		  ctx.width,
		], function (lmw, rmw, mmw, w) {
		  stream.push(lCtx.width, Math.min(w, lmw));
		  stream.push(rCtx.width, Math.min(w, rmw));
		  stream.push(mCtx.width, Math.min(w, mmw));
		  stream.push(lCtx.left, 0);
		  stream.push(rCtx.left, w - Math.min(w, rmw));
		  stream.push(mCtx.left, (w - Math.min(w, mmw)) / 2);
		});
		return {
		  minWidth: stream.combine([
			lI.minWidth,
			rI.minWidth,
			mI.minWidth,
		  ], function (l, r, m) {
			return (m > 0) ?
			  Math.max(m + 2 * l, m + 2 * r) :
			  l + r;
		  }),
		  minHeight: stream.combine([
			lI.minWidth,
			rI.minWidth,
			mI.minWidth,
			lI.minHeight,
			rI.minHeight,
			mI.minHeight,
		  ], function (lw, rw, mw, lh, rh, mh) {
			return function (w) {
			  return [lh(Math.min(w, lw)), rh(Math.min(w, rw)), mh(Math.min(w, mw))].reduce(mathMax);
			};
		  }),
		};
	  })(lrm.l || nothing, lrm.r || nothing, lrm.m || lrm.c || nothing);
	};
  }, lrmIsNotConfig);
  var alignLeft = function (c) {
	return alignLRM({
	  l: c,
	});
  };
  var alignRight = function (c) {
	return alignLRM({
	  r: c,
	});
  };
  var center = uncurryConfig(function (config) {
	return function (c) {
	  return alignLRM(config)({
		m: c,
	  });
	};
  });

  var alignTBM = uncurryConfig(function (config) {
	config = config || {};
	config.transition = (config.transition || 0) + 's';
	return function (tbm) {
	  return layout(function ($el, ctx, t, b, m) {
		$el.addClass('alignTBM');
		var tCtx = {
		  height: stream.create(),
		};
		var bCtx = {
		  height: stream.create(),
		  top: stream.create(),
		};
		var mCtx = {
		  height: stream.create(),
		  top: stream.create(),
		};
		var tI = ctx.append(t, tCtx);
		var bI = ctx.append(b, bCtx);
		var mI = ctx.append(m, mCtx);
		stream.combine([
		  tI.minHeight,
		  bI.minHeight,
		  mI.minHeight,
		  ctx.width,
		  ctx.height,
		], function (lmh, rmh, mmh, w, h) {
		  stream.push(tCtx.height, Math.min(h, lmh(w)));
		  stream.push(bCtx.height, Math.min(h, rmh(w)));
		  stream.push(mCtx.height, Math.min(h, mmh(w)));
		  stream.push(tCtx.top, 0);
		  stream.push(bCtx.top, Math.max(0, h - Math.min(h, rmh(w))));
		  stream.push(mCtx.top, Math.max(0, (h - Math.min(h, mmh(w))) / 2));
		});
		tI.$el.css('transition', 'top ' + config.transition);
		bI.$el.css('transition', 'top ' + config.transition);
		mI.$el.css('transition', 'top ' + config.transition);
		return {
		  minWidth: stream.combine([
			tI.minWidth,
			bI.minWidth,
			mI.minWidth,
		  ], function (t, b, m) {
			return [t, b, m].reduce(mathMax);
		  }),
		  minHeight: stream.combine([
			tI.minHeight,
			bI.minHeight,
			mI.minHeight,
		  ], function (tH, bH, mH) {
			return function (w) {
			  var t = tH(w);
			  var b = bH(w);
			  var m = mH(w);
			  return (m > 0) ?
				Math.max(m + 2 * t, m + 2 * b) :
				t + b;
			};
		  }),
		};
	  })(tbm.t || nothing, tbm.b || nothing, tbm.m || tbm.c || nothing);
	};
  }, tbmIsNotConfig);
  var alignVTop = function (c) {
	return alignTBM({
	  t: c,
	});
  };
  var alignVBottom = function (c) {
	return alignTBM({
	  b: c,
	});
  };
  var alignVMiddle = function (c) {
	return alignTBM({
	  m: c,
	});
  };
  var alignHLeft = function (c) {
	return alignLRM({
	  l: c,
	});
  };
  var alignHRight = function (c) {
	return alignLRM({
	  r: c,
	});
  };
  var alignHMiddle = function (c) {
	return alignLRM({
	  m: c,
	});
  };
  var alignMiddle = all([
	alignHMiddle,
	alignVMiddle,
  ]);

  // // var invertOnHover = function (c) {
  // // 	var invert = stream.once(false, 'invert');

  // // 	var choose = function (stream1, stream2) {
  // // 		return stream.combine([invert, stream1, stream2], function (i, v1, v2) {
  // // 			return i ? v2 : v1;
  // // 		}, 'choose stream');
  // // 	};


  // // 	return div.all([
  // // 		componentName('invert-on-hover'),
  // // 		child(c.and($css('transition', 'background-color 0.2s linear, color 0.1s linear'))),
  // // 		wireChildren(function (instance, context, i) {
  // // 			stream.pushAll(i.minHeight, instance.minHeight);
  // // 			stream.pushAll(i.minWidth, instance.minWidth);
  // // 			return [{
  // // 				backgroundColor: choose(context.backgroundColor, context.fontColor),
  // // 				fontColor: choose(context.fontColor, context.backgroundColor),
  // // 				top: stream.once(0),
  // // 				left: stream.once(0),
  // // 				width: context.width,
  // // 				height: context.height,
  // // 			}];
  // // 		}),
  // // 		mouseoverThis(function () {
  // // 			stream.push(invert, true);
  // // 		}),
  // // 		mouseoutThis(function () {
  // // 			stream.push(invert, false);
  // // 		}),
  // // 	]);
  // // };

  var border = function (colorS, amount, style) {
	var left = amount.left || amount.all || 0;
	var right = amount.right || amount.all || 0;
	var top = amount.top || amount.all || 0;
	var bottom = amount.bottom || amount.all || 0;
	var radius = amount.radius || 0;
	if ($.isNumeric(amount)) {
	  top = bottom = left = right = amount;
	}
	style = style || 'solid';

	if (!stream.isStream(colorS)) {
	  colorS = stream.once(colorS);
	}

	var colorStringS = stream.map(colorS, colorString);

	return layout(function ($el, ctx, c) {
	  $el.addClass('border');
	  // overflow hidden is necessary to prevent cutting off corners
	  // of border if there is a border radius
	  var i = ctx.append(c, {
		width: stream.map(ctx.width, function (w) {
		  return w - left - right;
		}),
		height: stream.map(ctx.height, function (h) {
		  return h - top - bottom;
		}),
		widthCss: stream.once('calc(100% - ' + px(left + right) + ')'),
		heightCss: stream.once('calc(100% - ' + px(top + bottom) + ')'),
	  });
	  i.$el.css('overflow', 'hidden');
	  i.$el.css('border-radius', px(radius));
	  stream.map(colorStringS, function (colorstring) {
		i.$el.css('border-left', px(left) + ' ' + style + ' ' + colorstring)
		  .css('border-right', px(right) + ' ' + style + ' ' + colorstring)
		  .css('border-top', px(top) + ' ' + style + ' ' + colorstring)
		  .css('border-bottom', px(bottom) + ' ' + style + ' ' + colorstring);
	  });
	  return {
		minWidth: stream.map(i.minWidth, function (mw) {
		  return mw + left + right;
		}),
		minHeight: stream.map(i.minHeight, function (mh) {
		  return function (w) {
			return mh(w) + top + bottom;
		  };
		}),
	  };
	});
  };

  var componentStream = function (cStream) {
	var error = new Error();
	return container(function ($el, ctx) {
	  $el.addClass('componentStream');
	  var i;
	  var unpushMW;
	  var unpushMH;
	  ctx.onRemove(function () {
		if (i) {
		  i.remove();
		}
	  });
	  var minWidth = stream.create();
	  var minHeight = stream.create();
	  var iStream = stream.reduce(cStream, function (i, c) {
		if (i) {
		  i.remove();
		}
		if (unpushMW) {
		  unpushMW();
		}
		if (unpushMH) {
		  unpushMH();
		}
		i = ctx.append(c, {
		  widthCss: stream.once('100%'),
		  heightCss: stream.once('100%'),
		});
		unpushMW = stream.pushAll(i.minWidth, minWidth);
		unpushMH = stream.pushAll(i.minHeight, minHeight);
		return i;
	  });
	  return {
		minWidth: minWidth,
		minHeight: minHeight,
	  };
	});
  };

  var componentStreamWithExit = function (cStream, exit, entrance) {
	var i;
	var ctx;
	exit = exit || function () {
	  var d = $.Deferred();
	  d.resolve();
	  return d.promise();
	};
	return container(function ($el, context) {
	  $el.addClass('component-stream-with-exit');
	  var localCStream = stream.create();
	  stream.pushAll(cStream, localCStream);
	  var minWidthS = stream.create();
	  var minHeightS = stream.create();
	  var instanceC = function (c) {
		if (i) {
		  (function (i) {
			setTimeout(function () {
			  exit(i, ctx).then(function () {
				i.remove();
			  });
			});
		  })(i);
		}
		ctx = {
		  widthCss: stream.once('100%'),
		  heightCss: stream.once('100%'),
		};
		i = context.append(c, ctx);
		i.$el.css('transition', 'inherit');
		i.$el.css('display', 'none');
		i.$el.prependTo($el);
		stream.pushAll(i.minWidth, minWidthS);
		stream.pushAll(i.minHeight, minHeightS);
		stream.defer(function () {
		  i.$el.css('display', '');
		  if (entrance) {
			entrance(i, ctx);
		  }
		});
	  };
	  stream.map(localCStream, function (c) {
		instanceC(c);
	  });
	  context.onRemove(function () {
		stream.end(localCStream);
		if (i) {
		  i.remove();
		}
	  });
	  return {
		minWidth: minWidthS,
		minHeight: minHeightS,
	  };
	});
  };

  var promiseComponent = function (cP, c1) {
	// var s = stream.once(nothing);
	var s = stream.create();
	if (c1) {
	  stream.push(s, c1);
	}
	cP.then(function (c) {
	  stream.push(s, c);
	}, function (error) {
	  console.log(error);
	}).catch(function (err) {
	  console.log(err);
	});
	return componentStream(s);
  };

  var toggleComponent = function (cs, indexStream) {
	return componentStream(stream.map(indexStream, function (i) {
	  return cs[i];
	}));
  };

  var modalDialog = function (c) {
	return function (s, transition) {
	  var open = stream.once(false);
	  stream.pushAll(s, open);

	  transition = transition || 0;

	  return layout(function ($el, context, c) {
		$el.addClass('modalDialog');

		var i = context.append(c, {
		  top: stream.once(0),
		  left: stream.once(0),
		  width: stream.map(windowWidth, function (ww) {
			return document.body.clientWidth;
		  }),
		  height: windowHeight,
		});

		$el = i.$el;
		$el.css('z-index', 100);
		$el.appendTo($('body'));
		$el.css('position', 'fixed');
		$el.css('transition', $el.css('transition') + ', opacity ' + transition + 's');
		$el.css('display', 'none');
		$el.css('pointer-events', 'initial');

		stream.onValue(open, function (on) {
		  if (on) {
			$el.css('display', '');
			setTimeout(function () {
			  $el.css('opacity', 1);
			}, 100);
		  }
		  else {
			$el.css('opacity', 0);
			setTimeout(function () {
			  $el.css('display', 'none');
			}, transition * 1000);
		  }
		});

		return {
		  minWidth: onceZeroS,
		  minHeight: stream.once(constant(0)),
		};
	  })(c);
	};
  };

  var toggleHeight = function (open) {
	return layout(function ($el, ctx, c) {
	  $el.css('overflow', 'hidden')
		.addClass('toggle-height');
	  var i = ctx.append(c);
	  return {
		minWidth: i.minWidth,
		minHeight: stream.combine([
		  i.minHeight,
		  open,
		], function (mh, onOff) {
		  return function (w) {
			return onOff ? mh(w) : 0;
		  };
		}),
	  };
	});
  };

  var dropdownPanel = function (source, panel, onOffS, config) {
	config = config || {};
	config.transition = config.transition || "0.5s";
	return layout(function ($el, ctx, source, panel) {
	  $el.addClass('dropdown-panel');
	  var panelCtx = {
		height: stream.create(),
		top: stream.create(),
	  };
	  var panelI = ctx.append(panel, panelCtx);
	  var sourceI = ctx.append(source);
	  useMinHeight(panelCtx, panelI);
	  stream.pushAll(ctx.height, panelCtx.top);
	  return {
		minWidth: stream.map(stream.combine([
		  panelI.minWidth,
		  sourceI.minWidth,
		], Math.max), function (mw) {
		  return mw;
		}),
		minHeight: sourceI.minHeight,
	  };
	})(source, layout(function ($el, ctx, panel) {
	  var context = {
		top: stream.combine([
		  onOffS,
		  ctx.height,
		], function (on, h) {
		  return on ? 0 : -h;
		})
	  };
	  if (config.panelHeightS) {
		stream.pushAll(context.height, config.panelHeightS);
	  }
	  var i = panel(context);
	  $el.css('overflow', 'hidden');
	  i.$el.css('transition', 'top ' + config.transition)
		.css('z-index', 1000);
	  return i;
	})(panel));
  };

  // generally for headers
  var sideSlidingPanel = function (source, panel, onOffS, config) {
	config = config || {};
	config.transition = config.transition || "0.5s";
	return layout(function ($el, ctx, source, panel) {
	  $el.addClass('side-sliding-panel');
	  setTimeout(function () {
		$el.css('overflow', 'visible');
	  });
	  var panelCtx = {
		width: stream.create(),
		height: stream.create(),
		left: stream.create(),
		top: stream.create(),
	  };
	  var panelI = ctx.append(panel, panelCtx);
	  var sourceI = ctx.append(source);
	  useMinWidth(panelCtx, panelI);
	  stream.combineInto([
		ctx.height,
		windowHeight,
	  ], function (sh, wh) {
		return wh - sh;
	  }, panelCtx.height);
	  stream.pushAll(ctx.height, panelCtx.top);
	  stream.combineInto([
		ctx.width,
		panelI.minWidth,
	  ], function (w, mw) {
		return w - mw;
	  }, panelCtx.left);
	  return {
		minWidth: stream.map(stream.combine([
		  panelI.minWidth,
		  sourceI.minWidth,
		], add), function (mw) {
		  return mw;
		}),
		minHeight: sourceI.minHeight,
	  };
	})(source, layout(function ($el, ctx, panel) {
	  var i = ctx.append(panel, {
		left: stream.combine([
		  onOffS,
		  ctx.width,
		], function (on, w) {
		  return on ? 0 : w;
		})
	  });
	  i.$el.css('transition', 'left ' + config.transition)
		.css('z-index', 1000);
	  return i;
	})(panel));
  };

  var fixedHeaderBody = uncurryConfig(function (config) {
	config.transition = config.transition || "0.5s";
	return layout(function ($el, ctx, bodyC, headerC) {
	  var headerHeightS = stream.create();
	  var headerI = headerC({
		width: ctx.width,
		height: headerHeightS,
	  });
	  stream.pushAll(stream.combine([
		ctx.width,
		headerI.minHeight,
	  ], function (w, mh) {
		return mh(w);
	  }), headerHeightS);
	  var bodyHeightS = stream.create();
	  var bodyI = bodyC({
		top: headerHeightS,
		width: ctx.width,
		height: bodyHeightS,
	  });
	  stream.pushAll(stream.combine([
		ctx.width,
		bodyI.minHeight,
	  ], function (w, mh) {
		return mh(w);
	  }), bodyHeightS);

	  headerI.$el.css('position', 'fixed');

	  setTimeout(function () {
		headerI.$el.css('transition', 'height ' + config.transition);
		bodyI.$el.css('transition', 'top ' + config.transition);
	  });

	  return {
		minWidth: stream.map(stream.combine([bodyI, headerI].map(function (i) {
		  return i.minWidth;
		})), function (hw, bw) {
		  return hw + bw;
		}),
		minHeight: stream.map(stream.combine([bodyI, headerI].map(function (i) {
		  return i.minHeight;
		})), function (hh, bh) {
		  return function (w) {
			return hh(w) + bh(w);
		  };
		}),
	  };
	});
  });

  var makeSticky = function (str) {
	str = str || onceZeroS;
	return layout(function ($el, context, c) {
	  $el.addClass('makeSticky');

	  var ctx = {
		widthCss: stream.once('100%'),
		heightCss: stream.once('100%'),
	  };
	  var i = context.append(c, ctx);
	  stream.combine([
		windowScroll,
		str,
		context.top,
		context.topOffset,
		context.left,
		context.leftOffset,
	  ], function (scroll, diffAmount, top, topOffset, left, leftOffset) {
		if (top + topOffset > scroll + diffAmount) {
		  $el.css('position', 'absolute');
		  $el.css('transition', '');
		  $el.css('left', px(left));
		}
		else if (top + topOffset < scroll + diffAmount) {
		  var leftPosition = left + leftOffset;
		  $el.css('position', 'fixed');
		  $el.css('left', px(leftPosition));
		  $el.css('top', px(diffAmount));
		  setTimeout(function () {
			$el.css('transition', 'inherit');
		  }, 20);
		}
	  });
	  return i;
	});
  };

  // // var stickyHeaderBody = function (body1, header, body2) {
  // // 	return div.all([
  // // 		componentName('stickyHeaderBody'),
  // // 		child(body1),
  // // 		child(body2),
  // // 		child(header),
  // // 		wireChildren(function (instance, context, body1I, body2I, headerI) {
  // // 			stream.pushAll(stream.map(stream.combine([body1I, body2I, headerI], function (i) {
  // // 				return i.minHeight;
  // // 			}), function () {
  // // 				var args = Array.prototype.slice.call(arguments);
  // // 				return args.reduce(add, 0);
  // // 			}), instance.minHeight);

  // // 			var fixedNow = false;

  // // 			return [{
  // // 				top: stream.once(0),
  // // 				left: stream.once(0),
  // // 				width: context.width,
  // // 				height: body1I.minHeight,
  // // 			}, {
  // // 				top: stream.combine([body1I.minHeight, headerI.minHeight], add),
  // // 				left: stream.once(0),
  // // 				width: context.width,
  // // 				height: body2I.minHeight,
  // // 			}, {
  // // 				top: stream.combine([body1I.minHeight, context.scroll, context.topOffset], function (mh, scroll, topOffset) {
  // // 					var $header = headerI.$el;
  // // 					mh = Math.floor(mh);
  // // 					if (mh > scroll + topOffset) {
  // // 						$header.css('position', 'absolute');
  // // 						$header.css('transition', '');
  // // 						if (fixedNow) {
  // // 							window.scrollTo(0, mh + topOffset);
  // // 						}
  // // 						fixedNow = false;
  // // 						return mh;
  // // 					}
  // // 					else if (mh < scroll + topOffset) {
  // // 						$header.css('position', 'fixed');
  // // 						setTimeout(function () {
  // // 							$header.css('transition', 'inherit');
  // // 						}, 20);
  // // 						if (!fixedNow) {
  // // 							window.scrollTo(0, mh + topOffset);
  // // 						}
  // // 						fixedNow = true;
  // // 						return topOffset;
  // // 					}
  // // 				}),
  // // 				left: stream.once(0),
  // // 				width: context.width,
  // // 				height: headerI.minHeight,
  // // 			}];
  // // 		}),
  // // 	]);
  // // };

  var useNthMinHeight = function (n) {
	return function (cells, mhs) {
	  var index = Math.min(n, cells.length - 1);
	  return mhs[index](cells[index].width);
	};
  };
  var useMaxHeight = function (cells, mhs) {
	return cells.reduce(function (a, cell, i) {
	  return Math.max(a, mhs[i](cell.width));
	}, 0);
  };

  var grid = uncurryConfig(function (config) {
	config = config || {};
	config.padding = config.padding || 0;
	config.surplusWidthFunc = config.surplusWidthFunc || ignoreSurplusWidth;
	config.surplusHeightFunc = config.surplusHeightFunc || ignoreSurplusHeight;
	config.rowHeight = config.rowHeight || useMaxHeight;
	config.maxPerRow = config.maxPerRow || 0;
	config.rowOrColumn = config.rowOrColumn || false;

	return function (cs) {
	  return layout(function ($el, ctx, cs) {
		$el.addClass('grid');
		var minWidth = stream.create();
		var minHeight = stream.create();
		if (cs.length === 0) {
		  stream.push(minWidth, 0);
		  stream.push(minHeight, constant(0));
		}
		var contexts = [];
		var is = cs.map(function (c) {
		  var context = {
			top: stream.create(),
			left: stream.create(),
			width: stream.create(),
			height: stream.create(),
		  };
		  contexts.push(context);
		  return ctx.append(c, context);
		});

		var minWidthsS = stream.combine(is.map(function (i) {
		  return i.minWidth;
		}), function () {
		  return Array.prototype.slice.call(arguments);
		});
		var minHeightsS = stream.combine(is.map(function (i) {
		  return i.minHeight;
		}), function () {
		  return Array.prototype.slice.call(arguments);
		});

		var computeRows = function (gridWidth, mws) {
		  if (config.allSameWidth) {
			var maxMW = mws.reduce(mathMax, 0);
			// thank you, keenan simons
			for (var ii = 0; ii < mws.length; ii++) {
			  mws[ii] = maxMW;
			}
		  }
		  var left;
		  var blankRow = function () {
			left = 0;
			return {
			  cells: [],
			  contexts: [],
			  height: 0,
			};
		  };

		  var rowsAndCurrentRow = mws.reduce(function (a, mw, index) {
			var rows = a.rows;
			var currentRow = a.currentRow;

			var widthUsedThisRow = currentRow.cells.reduce(function (a, cell) {
			  return a + cell.width + config.padding;
			}, 0);
			var widthNeeded = Math.min(mw, gridWidth);

			if ((config.maxPerRow > 0 &&
				 currentRow.cells.length === config.maxPerRow) ||
				(widthNeeded > 0 &&
				 widthNeeded + widthUsedThisRow > gridWidth)) {
			  rows.push(currentRow);
			  currentRow = blankRow();
			}

			currentRow.cells.push({
			  width: widthNeeded,
			  left: left,
			});
			currentRow.contexts.push(contexts[index]);

			left += widthNeeded + config.padding;
			return {
			  rows: rows,
			  currentRow: currentRow,
			};
		  }, {
			rows: [],
			currentRow: blankRow(),
		  });
		  var rows = rowsAndCurrentRow.rows;
		  rows.push(rowsAndCurrentRow.currentRow);
		  if (config.rowOrColumn && rowsAndCurrentRow.rows.length > 1) {
			rows = mws.map(function (mw, index) {
			  return {
				cells: [{
				  width: mw,
				  left: 0,
				}],
				contexts: [contexts[index]],
				height: 0,
			  };
			});
		  }

		  rows.map(function (row, i) {
			row.cells = config.surplusWidthFunc(gridWidth, row.cells, i);
		  });

		  return rows;
		};

		// todo: fix interaction of allSameWidth and useFullWidth
		stream.pushAll(stream.map(minWidthsS, function (mws) {
		  return mws.reduce(function (a, mw) {
			return config.useFullWidth ? a + mw + config.padding : Math.max(a, mw) + config.padding;
		  }, -config.padding);
		}), minWidth);
		stream.combineInto([
		  minWidthsS,
		  minHeightsS,
		], function (mws, mhs) {
		  return function (w) {
			var rows = computeRows(w, mws);
			var index = 0;
			var h = rows.map(function (row) {
			  var h = config.rowHeight(row.cells, mhs.slice(index, index + row.cells.length));
			  index += row.cells.length;
			  return h + config.padding;
			}).reduce(add, -config.padding);
			return h;
		  };
		}, minHeight);

		stream.combine([
		  ctx.width,
		  ctx.height,
		  minWidthsS,
		  minHeightsS,
		], function (gridWidth, gridHeight, mws, mhs) {
		  var rows = computeRows(gridWidth, mws);
		  var index = 0;
		  var top = 0;
		  rows.map(function (row) {
			row.height = config.rowHeight(row.cells, mhs.slice(index, index + row.cells.length));
			row.top = top;
			index += row.cells.length;
			top += row.height + config.padding;
		  });
		  if (config.bottomToTop) {
			rows = rows.slice(0).reverse();
		  }
		  rows = config.surplusHeightFunc(gridHeight, rows, config);
		  rows.map(function (row, i) {
			var positions = row.cells.map(function (cell) {
			  var position = {
				top: row.top,
				left: cell.left,
				width: cell.width,
				height: row.height,
			  };
			  return position;
			});
			positions.map(function (position, index) {
			  var context = row.contexts[index];
			  stream.push(context.top, position.top);
			  stream.push(context.left, position.left);
			  stream.push(context.width, position.width);
			  stream.push(context.height, position.height);
			});
		  });
		});

		return {
		  minWidth: minWidth,
		  minHeight: minHeight,
		};
	  })(cs);
	};
  });

  var withMinWidthStream = function (getMinWidthStream) {
	if ($.type(getMinWidthStream) === 'number') {
	  return minWidth(getMinWidthStream);
	}
	return layout(function ($el, ctx, c) {
	  $el.addClass('withMinWidthStream');
	  var i = ctx.append(c);
	  return {
		minWidth: $.isFunction(getMinWidthStream) ? getMinWidthStream(i, ctx) : getMinWidthStream,
		minHeight: i.minHeight,
	  };
	});
  };
  var minWidthAtLeast = function (number) {
	if (!stream.isStream(number)) {
	  number = stream.once(number);
	}
	return withMinWidthStream(function (i) {
	  return stream.combine([
		i.minWidth,
		number,
	  ], mathMax);
	});
  };
  var withMinHeightStream = function (getMinHeightStream) {
	if ($.type(getMinHeightStream) === 'number') {
	  return minHeight(getMinHeightStream);
	}
	return layout(function ($el, ctx, c) {
	  $el.addClass('withMinHeightStream');
	  var i = ctx.append(c);
	  var minHeightS = $.isFunction(getMinHeightStream) ? getMinHeightStream(i, ctx) : getMinHeightStream;
	  return {
		minWidth: i.minWidth,
		minHeight: stream.combine([
		  i.minHeight,
		  minHeightS,
		], function (mh, minHeight) {
		  return function (w) {
			return Math.max(mh(w), minHeight(w));
		  };
		}),
	  };
	});
  };
  var minHeightAtLeast = function (number) {
	if (!stream.isStream(number)) {
	  number = stream.once(number);
	}
	return withMinHeightStream(function (i) {
	  return stream.combine([
		i.minHeight,
		number,
	  ], function (mh, number) {
		return function (w) {
		  return Math.max(mh(w), number);
		};
	  });
	});
  };
  var withMaxHeightStream = function (heightS) {
	return layout(function ($el, ctx, c) {
	  $el.addClass('maxHeightStream');
	  var context = {
		height: stream.create(),
		top: stream.create(),
	  };
	  var i = ctx.append(c, context);
	  stream.pushAll(stream.combine([
		i.minHeight,
		ctx.width,
		ctx.height,
	  ], function (mh, w, h) {
		return Math.max(h, mh(w));
	  }), context.height);

	  var lastScroll = windowScroll.lastValue;
	  var scrollS = stream.map(windowScroll, function (s) {
		var dScroll = s - lastScroll;
		lastScroll = s;
		return dScroll;
	  });

	  var scrollTarget = 0;
	  var scrollTargetS = stream.combine([
		ctx.height,
		context.height,
		scrollS,
	  ], function (wh, h, s) {
		scrollTarget -= s;
		scrollTarget = Math.min(0, scrollTarget);
		scrollTarget = Math.max(wh - h, scrollTarget);
		return scrollTarget;
	  });
	  stream.pushAll(scrollTargetS, context.top);

	  return {
		minWidth: i.minWidth,
		minHeight: stream.combine([
		  heightS,
		  i.minHeight,
		], function (maxHeight, mh) {
		  return function (w) {
			return Math.min(maxHeight, mh(w));
		  };
		}),
	  };
	});
  };

  // // var atMostWindowBottom = function (c, distanceStream) {
  // // 	distanceStream = distanceStream || stream.once(0);
  // // 	return withMinHeightStream(function (instance, context) {
  // // 		return stream.combine([instance.minHeight,
  // // 							   context.top,
  // // 							   context.topOffset,
  // // 							   distanceStream,
  // // 							   windowResize], function (mh, t, ta, distance) {
  // // 								   return Math.min(mh, window.innerHeight - t - ta - distance);
  // // 							   });
  // // 	}, c);
  // // };

  var largestWidthThatFits = uncurryConfig(function (config) {
	return layout(function ($el, ctx, cs) {
	  $el.addClass('largest-width-that-fits');
	  var is = cs.map(function (c) {
		return ctx.append(c);
	  });
	  var allMinWidths = mapMinWidths(is);
	  var allMinHeights = mapMinHeights(is);
	  var chooseIndex = function (w, mws) {
		var index = mws.reduce(function (a, mw, index) {
		  return (mw <= w) && (a === null || mw > a.mw) ? {
			mw: mw,
			index: index,
		  } : a;
		}, null).index;
		if (index === null) {
		  console.log('none small enough, TODO: use smallest');
		}
		return index;
	  };
	  stream.combine([
		ctx.width,
		allMinWidths,
	  ], function (w, mws) {
		var i = chooseIndex(w, mws);
		is.map(function (instance, index) {
		  instance.$el.css('display', (index === i) ? '' : 'none');
		});
	  });
	  return {
		minWidth: stream.map(allMinWidths, function (mws) {
		  return mws.reduce(mathMax, 0);
		}),
		minHeight: stream.combine([
		  allMinWidths,
		  allMinHeights,
		], function (mws, mhs) {
		  return function (w) {
			var i = chooseIndex(w, mws);
			return mhs[i](w);
		  };
		}),
	  };
	});
  });

  var overlays = uncurryConfig(function (config) {
	return layout(function ($el, ctx, cs) {
	  $el.addClass('overlays');
	  var is = cs.map(function (c) {
		return ctx.append(c);
	  });
	  var chooseLargest = function (streams) {
		return stream.combine(streams, function () {
		  var args = Array.prototype.slice.call(arguments);
		  return args.reduce(mathMax, 0);
		});
	  };
	  return {
		minWidth: stream.combine(is.map(function (i) {
		  return i.minWidth;
		}), function () {
		  var args = Array.prototype.slice.call(arguments);
		  return args.reduce(mathMax, 0);
		}),
		minHeight: stream.combine(is.map(function (i) {
		  return i.minHeight;
		}), function () {
		  var args = Array.prototype.slice.call(arguments);
		  return function (w) {
			return args.map(apply(w)).reduce(mathMax, 0);
		  };
		}),
	  };
	});
  });


  // // var table = function (config, css)) {
  // // 	config = config || {};
  // // 	var padding = (config.padding || 0) * 2;
  // // 	return div.all(stream.map(css, function (cs) {
  // // 		return children(cs);
  // // 	})).all([
  // // 		componentName('table'),
  // // 		wireChildren(function () {
  // // 			var args = Array.prototype.slice.call(arguments);
  // // 			var instance = args[0];
  // // 			var context = args[1];
  // // 			var iss = args.slice(2);

  // // 			// we blindly assume all rows have the same number of columns

  // // 			// set table min width
  // // 			var maxMWs = stream.combine(iss.reduce(function (a, is) {
  // // 				stream.push(a, stream.combine(is.map(function (i) {
  // // 					return i.minWidth;
  // // 				}), function () {
  // // 					return Array.prototype.slice.call(arguments);
  // // 				}));
  // // 				return a;
  // // 			}, []), function () {
  // // 				var rowMWs = Array.prototype.slice.call(arguments);
  // // 				return rowMWs.reduce(function (a, rowMWs) {
  // // 					return stream.map(rowMWs, function (mw, i) {
  // // 						return Math.max(a[i] || 0, mw);
  // // 					});
  // // 				}, []);
  // // 			});
  // // 			stream.map(maxMWs, function (maxMWs) {
  // // 				var mw = maxMWs.reduce(function (a, mw) {
  // // 					return a + mw + padding;
  // // 				}, -padding);
  // // 				stream.push(instance.minWidth, mw);
  // // 			});

  // // 			// set table min height
  // // 			var rowMinHeights = iss.reduce(function (a, is) {
  // // 				stream.push(a, stream.combine(is.map(function (i) {
  // // 					return i.minHeight;
  // // 				}), function () {
  // // 					var args = Array.prototype.slice.call(arguments);
  // // 					return args.reduce(mathMax, 0);
  // // 				}));
  // // 				return a;
  // // 			}, []);
  // // 			stream.combine(rowMinHeights, function () {
  // // 				var mhs = Array.prototype.slice.call(arguments);
  // // 				var mh = mhs.reduce(function (a, mh) {
  // // 					return a + mh + padding;
  // // 				}, -padding);
  // // 				stream.push(instance.minHeight, mh);
  // // 			});

  // // 			return stream.map(rowMinHeights, function (mh, i) {
  // // 				return stream.map(iss[i], function (_, index) {
  // // 					return {
  // // 						width: stream.map(maxMWs, function (maxMWs) {
  // // 							return maxMWs[index];
  // // 						}),
  // // 						height: rowMinHeights[i],
  // // 						top: stream.combine(rowMinHeights.slice(0, i).concat([stream.once(0)]), function () {
  // // 							var mhs = Array.prototype.slice.call(arguments);
  // // 							return mhs.reduce(function (a, mh) {
  // // 								return a + mh + padding;
  // // 							}, -padding);
  // // 						}),
  // // 						left: stream.map(maxMWs, function (maxMWs) {
  // // 							return maxMWs.reduce(function (a, mw, mwI) {
  // // 								return a + (mwI < index ? mw + padding : 0);
  // // 							}, 0);
  // // 						}),
  // // 					};
  // // 				});
  // // 			});
  // // 		}),
  // // 	]);
  // // };

  var tabs = function (list, tabIndexS) {
	tabIndexS = tabIndexS || stream.once(0);
	return stack({})([
	  all([
		minWidth(0),
		$css('overflow-x', 'scroll'),
		$css('overflow-y', 'hidden'),
		$css('pointer-events', 'initial'),
	  ])(stack()([
		sideBySide({
		  surplusWidthFunc: centerSurplusWidth,
		})(list.map(function (item, index) {
		  return alignTBM()({
			b: all([
			  link,
			  clickThis(function () {
				stream.push(tabIndexS, index);
			  }),
			])(item.tab(tabIndexS, index)),
		  });
		})),
		all([
		  minHeight(_scrollbarWidth()) // cheater
		])(nothing),
	  ])),
	]);
  };

  var bar = {
	h: function (size) {
	  return minHeight(size)(nothing);
	},
	v: function (size) {
	  return minWidth(size)(nothing);
	},
  };
  var rectangle = function (size) {
	return all([
	  minHeight(size.v || size.x || 0),
	  minWidth(size.h || size.y || 0),
	])(nothing);
  };
  var matchStrings = function (stringsAndRouters) {
	return function (str) {
	  for (var i = 0; i < stringsAndRouters.length; i++ ) {
		var stringAndRouter = stringsAndRouters[i];
		if (str.indexOf(stringAndRouter.string) === 0) {
		  return stringAndRouter.router(str.substring(stringAndRouter.string.length));
		}
	  }
	};
  };

  var routeToComponent = function (component) {
	return function () {
	  return component;
	};
  };

  var routeToComponentF = function (componentF) {
	return function () {
	  return componentF();
	};
  };

  var routeToFirst = function (routers) {
	return function (str) {
	  for (var i = 0; i < routers.length; i++) {
		var result = routers[i](str);
		if (result) {
		  return result;
		}
	  }
	};
  };

  var routeMatchRest = function (f) {
	return function (str) {
	  // wrapping in a promise catches any exceptions that f throws
	  return promiseComponent(Q(str).then(f));
	};
  };

  var route = function (s, router) {
	return componentStream(stream.map(s, function (hash) {
	  return router(hash);
	}));
  };

  var scope = function (f) {
	return function (ctx) {
	  return f()(ctx);
	};
  };

  // types - object where keys are field names, values are formType
  // properties
  var formFor = function (types, names) {
	names = names || {};
	// defaults - optional object where keys are field names,
	// values are undefined OR a default value
	return function (defaults) {
	  defaults = defaults || {};
	  return function (mkOnSubmit) {
		// style - function taking a formType and a component,
		// returns a styled component
		return function (style) {
		  style = style || function (_, c) {
			return c;
		  };
		  var elements = {
			captcha: function (k, s) {
			  return div(function ($el, ctx, mw, mh) {
				$.getScript('https://www.google.com/recaptcha/api.js', function () {
				  auth.grecaptchaP.then(function (grecaptcha) {
					auth.grecaptchaSitekeyP.then(function (sitekey) {
					  grecaptcha.render($el[0], {
						sitekey: sitekey,
						callback: function (v) {
						  stream.push(s, v);
						},
					  });
					  mh();
					  mw();
					});
				  });
				});
			  });
			},
			checkbox: function (k, s) {
			  return input(function ($el, ctx, mw, mh) {
				mw();
				mh();
				$el.prop('id', k);
				$el.prop('name', k);
				$el.prop('type', 'checkbox');
				stream.onValue(s, function (v) {
				  $el.prop('checked', v ? 'checked' : '');
				});
				$el.on('blur', function () {
				  // added blur as a trigger after autocomplete
				  stream.push(s, $el.val());
				});
				$el.on('change', function () {
				  stream.push(s, $el.prop('checked'));
				});
			  });
			},
			date: function (k, s) {
			  return input(function ($el, ctx, mw, mh) {
				mw();
				mh();
				$el.prop('name', k);
				$el.prop('type', 'date');
				stream.onValue(s, function (v) {
				  $el.val(moment(v).format('YYYY-MM-DD'));
				});
				$el.on('blur', function () {
				  // added blur as a trigger after autocomplete
				  stream.push(s, $el.val());
				});
				$el.on('change', function () {
				  stream.push(s, moment($el.val()).toDate());
				});
			  });
			},
			dropdown: function (k, s, type) {
			  return select(function ($el, ctx, mw, mh) {
				mw();
				mh();
				$el.prop('name', k);
				type.options.map(function (option) {
				  if ('string' === $.type(option)) {
					option = {
					  name: option,
					  value: option,
					};
				  }
				  $(document.createElement('option'))
					.html(option.name)
					.prop('value', option.value)
					.appendTo($el);
				});
				if (!s.lastValue) {
				  stream.push(s, $el.val());
				}
				stream.onValue(s, function (v) {
				  $el.val(v);
				});
				$el.on('blur', function () {
				  // added blur as a trigger after autocomplete
				  stream.push(s, $el.val());
				});
				$el.on('change', function () {
				  stream.push(s, $el.val());
				});
			  });
			},
			image: function (k, s) {
			  return input(function ($el, ctx, mw, mh) {
				mw();
				mh();
				$el.prop('name', k);
				$el.prop('type', 'file');
				$el.prop('accept', 'image/*');
				$el.on('blur', function () {
				  // added blur as a trigger after autocomplete
				  stream.push(s, $el.val());
				});
				$el.on('change', function (ev) {
				  stream.push(s, ev.target.files[0]);
				});
			  });
			},
			number: function (k, s) {
			  return input(function ($el, ctx, mw, mh) {
				mw();
				mh();
				$el.prop('name', k);
				$el.prop('type', 'number');
				stream.onValue(s, function (v) {
				  $el.val(v);
				});
				$el.on('blur', function () {
				  // added blur as a trigger after autocomplete
				  stream.push(s, $el.val());
				});
				$el.on('change', function () {
				  stream.push(s, $el.val());
				});
			  });
			},
			password: function (k, s) {
			  return input(function ($el, ctx, mw, mh) {
				mw();
				mh();
				$el.prop('name', k);
				$el.prop('type', 'password');
				stream.onValue(s, function (v) {
				  $el.val(v);
				});
				$el.on('blur', function () {
				  // added blur as a trigger after autocomplete
				  stream.push(s, $el.val());
				});
				$el.on('change', function () {
				  stream.push(s, $el.val());
				});
			  });
			},
			radios: function (k, s, type) {
			  return type.options.map(function (option) {
				return input(function ($el, ctx, mw, mh) {
				  mw();
				  mh();
				  $el.prop('id', option);
				  $el.prop('value', option);
				  $el.prop('name', k);
				  $el.prop('type', 'radio');
				  stream.onValue(s, function (v) {
					if (v === option) {
					  $el.prop('checked', v ? 'checked' : '');
					}
				  });
				  $el.on('blur', function () {
					// added blur as a trigger after autocomplete
					stream.push(s, $el.val());
				  });
				  $el.on('change', function () {
					if ($el.prop('checked')) {
					  stream.push(s, option);
					}
				  });
				});
			  });
			},
			starRating: function (k, s) {
			  return input(function ($el) {
				$el.prop('name', k);
				$el.prop('type', 'hidden');
				stream.onValue(s, function (v) {
				  $el.val(v);
				});
				return {
				  minWidth: onceZeroS,
				  minHeight: stream.once(constant(0)),
				};
			  });
			},
			text: function (k, s) {
			  return input(function ($el, ctx, mw, mh) {
				mw();
				mh();
				$el.prop('name', k);
				stream.onValue(s, function (v) {
				  $el.val(v);
				});
				$el.on('blur', function () {
				  // added blur as a trigger after autocomplete
				  stream.push(s, $el.val());
				});
				$el.on('change', function () {
				  stream.push(s, $el.val());
				});
				$el.on('keyup', function () {
				  stream.push(s, $el.val());
				});
			  });
			},
			textarea: function (k, s) {
			  return textarea(function ($el, ctx) {
				var mw = stream.once($el.outerWidth());
				// 20 is a fucking magic number, meh
				var mh = stream.once(constant($el.outerHeight() + 20));
				$el.prop('name', k);
				stream.onValue(s, function (v) {
				  $el.val(v);
				});
				$el.on('blur', function () {
				  // added blur as a trigger after autocomplete
				  stream.push(s, $el.val());
				});
				$el.on('change', function () {
				  stream.push(s, $el.val());
				});
				$el.on('keyup', function () {
				  stream.push(s, $el.val());
				});
				var lastOuterWidth = $el.outerWidth();
				var lastOuterHeight = $el.outerHeight();
				$('body').on('mousemove', function () {
				  // this handler is a memory leak, should unbind it
				  var currentOuterWidth = $el.outerWidth();
				  var currentOuterHeight = $el.outerHeight();
				  if (lastOuterWidth !== currentOuterWidth) {
					stream.push(mw, currentOuterWidth);
					lastOuterWidth = currentOuterWidth;
				  }
				  if (lastOuterHeight !== currentOuterHeight) {
					stream.push(mh, constant(currentOuterHeight - 20));
					lastOuterHeight = currentOuterHeight;
				  }
				});
				$el.on('click', function () {
				  stream.push(mw, $el.outerWidth());
				  stream.push(mh, constant($el.outerHeight() - 20));
				});
				stream.onValue(ctx.width, function (w) {
				  $el.css('width', px(w));
				});
				stream.onValue(ctx.height, function (h) {
				  $el.css('height', px(h));
				});
				return {
				  minWidth: mw,
				  minHeight: mh,
				};
			  });
			},
			time: function (k, s) {
			  return input(function ($el, ctx, mw, mh) {
				mw();
				mh();
				$el.prop('name', k);
				$el.prop('type', 'time');
				stream.onValue(s, function (v) {
				  $el.val(v);
				});
				$el.on('blur', function () {
				  // added blur as a trigger after autocomplete
				  stream.push(s, $el.val());
				});
				$el.on('change', function () {
				  stream.push(s, $el.val());
				});
			  });
			},
		  };
		  var keys = Object.keys(types);
		  return function (f) {
			var streamsObj = keys.reduce(function (obj, k) {
			  var d = defaults[k];
			  obj[k] = d ? stream.once(d) : stream.create();
			  return obj;
			}, {});
			var inputsObj = keys.reduce(function (obj, k) {
			  var type = types[k];
			  obj[k] = type && style(type, elements[type.type](k, streamsObj[k], type, names[k]), names[k], k, streamsObj[k]);
			  return obj;
			}, {});
			var submit = function (name) {
			  return style(formType.button, pushButton(name));
			};
			var onSubmit = mkOnSubmit(streamsObj);
			return layout(form, function ($el, ctx, c) {
			  $el.on('submit', onSubmit.onSubmit);
			  return ctx.append(c);
			})(f(streamsObj, inputsObj, submit, onSubmit.resultS));
		  };
		};
	  };
	};
  };

  var hcj = {
	color: {
	  color: color,
	  create: color,
	  toString: colorString,
	},
	component: {
	  $$: $$,
	  $addClass: $addClass,
	  $attr: $attr,
	  $css: $css,
	  $on: $on,
	  $prop: $prop,
	  adjustPosition: adjustPosition,
	  alignH: alignLRM,
	  alignHorizontal: alignLRM,
	  alignHLeft: alignHLeft,
	  alignHMiddle: alignHMiddle,
	  alignHRight: alignHRight,
	  alignLRM: alignLRM,
	  alignMiddle: alignMiddle,
	  alignTBM: alignTBM,
	  alignV: alignTBM,
	  alignVBottom: alignVBottom,
	  alignVertical: alignTBM,
	  alignVMiddle: alignVMiddle,
	  alignVTop: alignVTop,
	  all: all,
	  and: and,
	  backgroundColor: backgroundColor,
	  bar: bar,
	  border: border,
	  changeThis: changeThis,
	  clickThis: clickThis,
	  component: component,
	  componentStream: componentStreamWithExit,
	  crop: crop,
	  cssStream: cssStream,
	  dimensions: withDimensions,
	  dropdownPanel: dropdownPanel,
	  empty: empty,
	  fadeIn: fadeIn,
	  grid: grid,
	  hoverColor: hoverColor,
	  hoverThis: hoverThis,
	  keepAspectRatio: keepAspectRatio,
	  keydownThis: keydownThis,
	  keyupThis: keyupThis,
	  image: image,
	  largestWidthThatFits: largestWidthThatFits,
	  layout: layout,
	  link: link,
	  linkTo: linkTo,
	  margin: margin,
	  maxHeightStream: withMaxHeightStream,
	  minHeight: withMinHeightStream,
	  minHeightStream: withMinHeightStream,
	  minHeightAtLeast: minHeightAtLeast,
	  minWidth: withMinWidthStream,
	  minWidthAtLeast: minWidthAtLeast,
	  minWidthStream: withMinWidthStream,
	  mousedownThis: mousedownThis,
	  mousemoveThis: mousemoveThis,
	  mouseoverThis: mouseoverThis,
	  mouseoutThis: mouseoutThis,
	  mouseupThis: mouseupThis,
	  nothing: nothing,
	  onThis: onThis,
	  overlays: overlays,
	  promiseComponent: promiseComponent,
	  rectangle: rectangle,
	  scope: scope,
	  sideBySide: sideBySide,
	  sideSlidingPanel: sideSlidingPanel,
	  slideIn: slideIn,
	  slider: slider,
	  slideshow: slideshow,
	  stack: stack,
	  submitThis: submitThis,
	  tabs: tabs,
	  text: text,
	  toggleHeight: toggleHeight,
	  wrap: wrap,
	},
	// Remember, elements are not components.  This is why they are
	// under 'el' and not 'c.'  If you want an empty component, use
	// 'c.empty'.
	element: {
	  a: a,
	  button: button,
	  div: div,
	  form: form,
	  iframe: iframe,
	  img: img,
	  input: input,
	  label: label,
	  li: li,
	  option: option,
	  p: p,
	  pre: pre,
	  select: select,
	  textarea: textarea,
	  ul: ul,
	},
	forms: {
	  formFor: formFor,
	},
	funcs: {
	  constant: constant,
	  id: id,
	  rowHeight: {
		useMaxHeight: useMaxHeight,
		useNthMinHeight: useNthMinHeight,
	  },
	  surplusWidth: {
		ignore: ignoreSurplusWidth,
		center: centerSurplusWidth,
		centerFirstRowThenAlignLeft: centerFirstRowThenAlignLeftSurplusWidth,
		evenlySplit: evenlySplitSurplusWidth,
		evenlySplitCenter: evenlySplitCenterSurplusWidth,
		justify: justifySurplusWidth,
		justifyAndCenter: justifyAndCenterSurplusWidth,
		giveToNth: giveToNth,
	  },
	  surplusHeight: {
		ignore: ignoreSurplusHeight,
		center: centerSurplusHeight,
		giveToNth: giveHeightToNth,
	  },
	},
	rootComponent: rootComponent,
	routing: {
	  matchStrings: matchStrings,
	  route: route,
	  routeMatchRest: routeMatchRest,
	  routeToComponentF: routeToComponentF,
	  routeToFirst: routeToFirst,
	},
	stream: stream,
	unit: {
	  px: px,
	},
	viewport: {
	  heightS: windowHeight,
	  scrollS: windowScroll,
	  widthS: windowWidth,
	},
  };

  window.hcj = hcj;
})();
